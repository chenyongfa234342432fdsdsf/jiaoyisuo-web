import { QChatChannelUnreadInfo, QChatServerUnreadInfo } from './QChatChannelServiceInterface';
import { QChatMessage, QChatMessageUpdateOperatorInfo, QChatSystemNotification } from './QChatMsgServiceInterface';
import { LoginResult, MultiSpotLoginResult, TKickedReason, WillReconnectEventResult, QChatInitializeOptions, QChatOtherOptions } from './types';
export interface QChatInterface {
    /**
     * 实例状态
     */
    status: NIMEQChatInstanceStatus;
    /**
     * 建立连接，并且登录
     */
    login(): Promise<void>;
    /**
     * 断开连接。
     *
     * 退出登录状态，并断开 websocket 连接
     *
     * logout 完成后，实例不会被销毁，可再次 login 方法登录
     */
    logout(): Promise<void>;
    /**
     * 更新初始化传入的参数，在初始化完成后使用
     *
     * 请注意！传入的参数会在下一次调用login或重连时生效
     */
    setOptions(options: QChatInitializeOptions): void;
    /**
     * 销毁实例
     *
     * 销毁当前 IM 实例，同时会退出登录状态，并断开 websocket 连接
     *
     * 移除所有监听事件，销毁部分内部变量，并且此实例再也无法调用 login 恢复 IM 连接
     */
    destroy(): Promise<void>;
    /**
     * 踢出当前用户从其它端登录上来的连接
     */
    kickOtherClients(options: KickOtherClientsOptions): Promise<KickOtherClientsResult>;
}
/**
 * @Multi_Lang_Tag
 * @locale cn
 * 静态方法
 * @locale
 *
 * @locale en
 * Static method
 * @locale
 */
export interface QChatInterfaceStatic {
    /**
     * 构造函数
     */
    new (options?: QChatInitializeOptions, otherOptions?: QChatOtherOptions): QChatInterface;
    /**
     * 单例模式获取实例
     */
    getInstance(_options?: QChatInitializeOptions, _otherOptions?: QChatOtherOptions): QChatInterface;
    /**
     * 设置适配器
     * @param _newAdapters 适配器
     */
    setAdapters(_newAdapters: any): void;
}
/**
 * @Multi_Lang_Tag
 * @locale cn
 * 实例的状态标识
 *
 * - unconnected: 尚未建立连接(初始化、主动登出、达到最大重连次数)
 * - connecting: 正在建立连接中
 * - connected: 已连接，尚未完成鉴权认证
 * - logined: 已连接, 并且完成了鉴权认证，可以正常开始发送协议
 * - waitReconnect: 等待重连中
 * - destroyed: 实例已经销毁
 * @locale
 *
 * @locale en
 * Status of the instance
 *
 * - unconnected: no connection has been established(Initialization, active logout, and maximum reconnection times)
 * - connecting: Establishing connection
 * - connected: Connected, authentication has not been completed
 * - logined: Connected and completed the authentication
 * - waitReconnect: Waiting for reconnection
 * - destroyed: The instance has been destroyed
 * @locale
 */
export declare type NIMEQChatInstanceStatus = 'unconnected' | 'connecting' | 'connected' | 'logined' | 'waitReconnect' | 'destroyed';
/**
 * Example：
 *
 * const instance = new SDK()
 *
 * instance.on('msg', msg => { console.log(msg) }
 */
export interface QChatEventInterface {
    /**
     * 登录成功
     */
    logined: [loginResult: LoginResult];
    /**
     * 被踢下线
     */
    kicked: [kickedReason: TKickedReason];
    /**
     * 多端登陆通知
     */
    multiSpotLogin: [multiLoginResults: MultiSpotLoginResult[]];
    /**
     * 开始自动重连
     */
    willReconnect: [result: WillReconnectEventResult];
    /**
     * 连接断开
     */
    disconnect: [];
    /**
     * 收到消息
     */
    message: [msg: QChatMessage];
    /**
     * 收到消息更新
     */
    messageUpdate: [msg: QChatMessage, updateOperatorInfo: QChatMessageUpdateOperatorInfo];
    /**
     * @deprecated 频道收到消息未读通知,这个事件即将废弃，由 {@link QChatEventInterface.unreadInfos}取代
     */
    unreadInfo: [msg: QChatChannelUnreadInfo];
    /**
     * 多个频道收到消息未读通知
     */
    unreadInfos: [msg: QChatChannelUnreadInfo[]];
    /**
     * 收到服务器总消息未读通知
     */
    serverUnreadInfo: [msg: QChatServerUnreadInfo];
    /**
     * 收到系统通知
     */
    systemNotification: [notificationEvent: SystemNotificationEvent];
    /**
     * 收到系统通知更新
     */
    systemNotificationUpdate: [sysNotification: QChatSystemNotification];
    /**
     * 同步阶段-收到未读的离线系统通知
     */
    syncSystemNotifications: [sysNotifications: QChatSystemNotification[]];
    /**
     * 收到“正在输入”事件
     */
    recvTypingEvent: [event: QChatRecvTypingEventResult];
    /**
     * 以下是和QChatMedia模块相关的事件
     */
    /**
     * 断开rtc房间连接
     */
    qchatMediaDisconnect: [];
    /**
     * rtc房间连接成功
     */
    connectChannel: [];
    /**
     * 成员进入RTC频道
     */
    memberJoinRTCChannel: [accids: string[]];
    /**
     * 成员离开RTC频道
     */
    memberLeaveRTCChannel: [accids: string[]];
    /**
     * RTC频道错误
     */
    RTCChannelError: [code: number | string];
    /**
     * 提示房间内谁正在说话及说话者瞬时音量的回调，不包含本端，如果列表为空，则表示此时远端没有人说话。
     */
    onRtcAudioVolumeIndication: [data: {
        serUuid: string;
        volume: number;
    }[]];
    /**
     * 成员音频状态回调
     */
    memberAudioMuteChanged: [data: {
        memberAccId: string;
        mute: boolean;
        operateByAccId: string;
    }];
    /**
     * 成员屏幕共享状态回调
     */
    memberScreenShareStateChanged: [data: {
        memberAccId: string;
        isSharing: boolean;
        operateByAccId: string;
    }];
    /**
     * 成员视频状态回调
     */
    memberVideoMuteChanged: [data: {
        memberAccId: string;
        mute: boolean;
        operateByAccId: string;
    }];
}
export declare type QChatRecvTypingEventResult = {
    /**
     * 服务器id
     */
    serverId: string;
    /**
     * 频道id
     */
    channelId: string;
    /**
     * 扩展字段，推荐使用 JSON 格式字符串。
     */
    ext?: string;
    /**
     * 事件发送者的 account id
     */
    fromAccount: string;
    /**
     * 发送者的昵称
     */
    fromNick?: string;
    /**
     * 发送时间戳
     */
    time: number;
};
export declare enum ESystemNotificationEventFeature {
    /**
     * 默认，在线接到的
     */
    default = 1,
    /**
     * 同步时接到的离线系统通知
     */
    sync = 2
}
export declare type SystemNotificationEvent = {
    /**
     * 此事件的特性，用于区别接到的是：同步阶段的离线的系统通知、在线接到的系统通知
     */
    feature: keyof typeof ESystemNotificationEventFeature;
    systemNotifications: QChatSystemNotification[];
};
export declare type KickOtherClientsOptions = {
    /**
     * 要踢掉的端的设备号数组
     *
     * 端设备号能在 multiPortLogin 多端登陆事件里拿到
     */
    deviceIds: string[];
};
export declare type KickOtherClientsResult = {
    /**
     * 成功被踢掉的设备号数组
     */
    deviceIds: string[];
};
