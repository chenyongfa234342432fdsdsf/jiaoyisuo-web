"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHtmlHeadIfMissing = exports.injectHtmlSnippets = void 0;
const utils_1 = require("../../utils");
const POSITIONS = ['HEAD_OPENING', 'HEAD_CLOSING', 'DOCUMENT_END', 'STREAM'];
function injectHtmlSnippet(position, htmlSnippet, htmlString, injectToStream) {
    htmlSnippet = getHtmlSnippet(htmlSnippet);
    if (position === 'HEAD_OPENING') {
        (0, utils_1.assert)(tagOpeningExists('head', htmlString));
        htmlString = injectAtOpeningTag('head', htmlString, htmlSnippet);
        return htmlString;
    }
    if (position === 'HEAD_CLOSING') {
        (0, utils_1.assert)(tagClosingExists('head', htmlString));
        htmlString = injectAtClosingTag('head', htmlString, htmlSnippet);
        return htmlString;
    }
    if (position === 'DOCUMENT_END') {
        if (tagClosingExists('body', htmlString)) {
            return injectAtClosingTag('body', htmlString, htmlSnippet);
        }
        if (tagClosingExists('html', htmlString)) {
            return injectAtClosingTag('html', htmlString, htmlSnippet);
        }
        return htmlString + '\n' + htmlSnippet;
    }
    if (position === 'STREAM') {
        (0, utils_1.assert)(injectToStream);
        injectToStream(htmlSnippet, { flush: true });
        return htmlString;
    }
    (0, utils_1.assert)(false);
}
function injectHtmlSnippets(htmlString, snippets, injectToStream) {
    const snippetsBundled = bundleSnippets(snippets);
    snippetsBundled.forEach((snippet) => {
        htmlString = injectHtmlSnippet(snippet.position, snippet.htmlSnippet, htmlString, injectToStream);
    });
    return htmlString;
}
exports.injectHtmlSnippets = injectHtmlSnippets;
// Is this really needed?
function bundleSnippets(snippets) {
    const snippetsBundled = [];
    POSITIONS.forEach((position) => {
        const htmlSnippets = snippets
            .filter((h) => h.position === position)
            .map((h) => getHtmlSnippet(h.htmlSnippet));
        if (htmlSnippets.length > 0) {
            const htmlSnippetsBundled = htmlSnippets.join('');
            snippetsBundled.push({
                htmlSnippet: htmlSnippetsBundled,
                position
            });
        }
    });
    return snippetsBundled;
}
function getHtmlSnippet(htmlSnippet) {
    return typeof htmlSnippet !== 'string' ? htmlSnippet() : htmlSnippet;
}
function injectAtOpeningTag(tag, htmlString, htmlSnippet) {
    const openingTag = getTagOpening(tag);
    const matches = htmlString.match(openingTag);
    (0, utils_1.assert)(matches && matches.length >= 1);
    const tagInstance = matches[0];
    (0, utils_1.assert)(tagInstance);
    const htmlParts = htmlString.split(tagInstance);
    (0, utils_1.assert)(htmlParts.length >= 2);
    // Insert `htmlSnippet` after first `tagInstance`
    const before = (0, utils_1.slice)(htmlParts, 0, 1);
    const after = (0, utils_1.slice)(htmlParts, 1, 0).join(tagInstance);
    return before + tagInstance + htmlSnippet + after;
}
function injectAtClosingTag(tag, htmlString, htmlSnippet) {
    const tagClosing = getTagClosing(tag);
    const matches = htmlString.match(tagClosing);
    (0, utils_1.assert)(matches && matches.length >= 1);
    const tagInstance = matches[0];
    (0, utils_1.assert)(tagInstance);
    const htmlParts = htmlString.split(tagInstance);
    (0, utils_1.assert)(htmlParts.length >= 2);
    // Insert `htmlSnippet` before last `tagClosing`
    const before = (0, utils_1.slice)(htmlParts, 0, -1).join(tagInstance);
    const after = (0, utils_1.slice)(htmlParts, -1, 0);
    return before + htmlSnippet + tagInstance + after;
}
function createHtmlHeadIfMissing(htmlString) {
    const assertion = () => (0, utils_1.assert)(tagOpeningExists('head', htmlString) && tagClosingExists('head', htmlString));
    if (tagOpeningExists('head', htmlString) && tagClosingExists('head', htmlString)) {
        assertion();
        return htmlString;
    }
    const htmlSnippet = '<head></head>';
    if (tagOpeningExists('html', htmlString)) {
        htmlString = injectAtOpeningTag('html', htmlString, htmlSnippet);
        assertion();
        return htmlString;
    }
    if (tagOpeningExists('!doctype', htmlString)) {
        htmlString = injectAtOpeningTag('!doctype', htmlString, htmlSnippet);
        assertion();
        return htmlString;
    }
    htmlString = htmlSnippet + '\n' + htmlString;
    assertion();
    return htmlString;
}
exports.createHtmlHeadIfMissing = createHtmlHeadIfMissing;
// Pay attention to performance when searching for tags
// Use the most effective way to test or match tag existence
// Use tag existence checking with caution as it is costly operation
function tagOpeningExists(tag, htmlString) {
    const tagOpeningRE = getTagOpening(tag);
    return tagOpeningRE.test(htmlString);
}
function tagClosingExists(tag, htmlString) {
    const tagClosingRE = getTagClosing(tag);
    return tagClosingRE.test(htmlString);
}
function getTagOpening(tag) {
    const tagOpening = new RegExp(`<${tag}(>| [^>]*>)`, 'i');
    return tagOpening;
}
function getTagClosing(tag) {
    const tagClosing = new RegExp(`</${tag}>`, 'i');
    return tagClosing;
}
