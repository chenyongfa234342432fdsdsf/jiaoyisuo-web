"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadPageFilesServer = exports.renderStatic404Page = exports.prerenderPage = exports.renderPage = void 0;
const route_1 = require("../shared/route");
const renderHtml_1 = require("./html/renderHtml");
const getPageFiles_1 = require("../shared/getPageFiles");
const analyzePageClientSide_1 = require("../shared/getPageFiles/analyzePageClientSide");
const getHook_1 = require("../shared/getHook");
const stringify_1 = require("@brillout/json-serializer/stringify");
const picocolors_1 = __importDefault(require("picocolors"));
const utils_1 = require("./utils");
const getPageAssets_1 = require("./renderPage/getPageAssets");
const sortPageContext_1 = require("../shared/sortPageContext");
const assertHookResult_1 = require("../shared/assertHookResult");
const stream_1 = require("./html/stream");
const serializePageContextClientSide_1 = require("./serializePageContextClientSide");
const addComputedUrlProps_1 = require("../shared/addComputedUrlProps");
const assertPageContextProvidedByUser_1 = require("../shared/assertPageContextProvidedByUser");
const RenderErrorPage_1 = require("./renderPage/RenderErrorPage");
const log404_1 = require("./renderPage/log404");
const globalContext_1 = require("./globalContext");
const viteLogging_1 = require("./viteLogging");
const loadPageFilesServerSide_1 = require("../shared/getPageFiles/analyzePageServerSide/loadPageFilesServerSide");
const handlePageContextRequestUrl_1 = require("./renderPage/handlePageContextRequestUrl");
async function renderPage_(pageContextInit, pageContext) {
    {
        const pageContextInitAddendum = await initializePageContext(pageContextInit);
        (0, utils_1.objectAssign)(pageContext, pageContextInitAddendum);
    }
    if ('httpResponse' in pageContext) {
        (0, utils_1.assert)(pageContext.httpResponse === null);
        return pageContext;
    }
    (0, addComputedUrlProps_1.addComputedUrlProps)(pageContext);
    // *** Route ***
    const routeResult = await (0, route_1.route)(pageContext);
    (0, utils_1.objectAssign)(pageContext, routeResult.pageContextAddendum);
    const is404 = (0, utils_1.hasProp)(pageContext, '_pageId', 'string') ? null : true;
    (0, utils_1.objectAssign)(pageContext, { is404 });
    (0, utils_1.objectAssign)(pageContext, { errorWhileRendering: null });
    return renderPageContext(pageContext);
}
async function renderPageContext(pageContext) {
    if (pageContext.is404)
        (0, log404_1.log404)(pageContext);
    const isError = pageContext.is404 || pageContext.errorWhileRendering;
    if (isError) {
        (0, utils_1.assert)(pageContext._pageId === null);
        const errorPageId = (0, route_1.getErrorPageId)(pageContext._allPageIds);
        if (errorPageId) {
            (0, utils_1.objectAssign)(pageContext, { _pageId: errorPageId });
        }
        else {
            // The user hasn't define a `_error.page.js`
            (0, utils_1.objectAssign)(pageContext, { _pageId: null });
            return handleErrorWithoutErrorPage(pageContext);
        }
    }
    // We now resolved `pageContext._pageId`. It can either be the:
    //  - ID of the page matching the routing, or the
    //  - ID of the error page `_error.page.js`.
    (0, utils_1.assert)((0, utils_1.hasProp)(pageContext, '_pageId', 'string'));
    const pageFiles = await loadPageFilesServer(pageContext);
    (0, utils_1.objectAssign)(pageContext, pageFiles);
    if (!isError) {
        await executeOnBeforeRenderHooks(pageContext);
    }
    else {
        try {
            await executeOnBeforeRenderHooks(pageContext);
        }
        catch (err) {
            logErrorIfDifferentFromOriginal(err, pageContext.errorWhileRendering);
        }
    }
    if (pageContext._isPageContextRequest) {
        if (isError) {
            (0, utils_1.objectAssign)(pageContext, { _isError: true });
        }
        const body = (0, serializePageContextClientSide_1.serializePageContextClientSide)(pageContext);
        const httpResponse = createHttpResponseObject(body, null, pageContext);
        (0, utils_1.objectAssign)(pageContext, { httpResponse });
        return pageContext;
    }
    const renderHookResult = await executeRenderHook(pageContext);
    if (renderHookResult.htmlRender === null) {
        (0, utils_1.objectAssign)(pageContext, { httpResponse: null });
        return pageContext;
    }
    else {
        const { htmlRender, renderFilePath } = renderHookResult;
        const httpResponse = createHttpResponseObject(htmlRender, renderFilePath, pageContext);
        (0, utils_1.objectAssign)(pageContext, { httpResponse });
        return pageContext;
    }
}
function handleErrorWithoutErrorPage(pageContext) {
    (0, utils_1.assert)(pageContext._pageId === null); // User didn't define a `_error.page.js` file
    (0, utils_1.assert)(pageContext.errorWhileRendering || pageContext.is404);
    warnMissingErrorPage(pageContext);
    if (!pageContext._isPageContextRequest) {
        (0, utils_1.objectAssign)(pageContext, { httpResponse: null });
        return pageContext;
    }
    else {
        const httpResponse = createHttpResponseObject((0, stringify_1.stringify)({ serverSideError: true }), null, pageContext);
        (0, utils_1.objectAssign)(pageContext, { httpResponse });
        return pageContext;
    }
}
async function initializePageContext(pageContextInit) {
    const { urlOriginal } = pageContextInit;
    (0, utils_1.assert)(urlOriginal);
    const pageContextAddendum = {
        _isPreRendering: false,
        ...pageContextInit
    };
    if (urlOriginal.endsWith('/__vite_ping') || urlOriginal.endsWith('/favicon.ico') || !(0, utils_1.isParsable)(urlOriginal)) {
        (0, utils_1.objectAssign)(pageContextAddendum, { httpResponse: null, errorWhileRendering: null });
        return pageContextAddendum;
    }
    const globalContext = await (0, globalContext_1.getGlobalContext)(pageContextAddendum._isPreRendering);
    (0, utils_1.objectAssign)(pageContextAddendum, globalContext);
    {
        const { pageFilesAll, allPageIds } = await (0, getPageFiles_1.getPageFilesAll)(false, globalContext._isProduction);
        (0, utils_1.objectAssign)(pageContextAddendum, {
            _pageFilesAll: pageFilesAll,
            _allPageIds: allPageIds
        });
    }
    {
        (0, utils_1.assert)(urlOriginal.startsWith('/') || urlOriginal.startsWith('http'));
        const { urlWithoutPageContextRequestSuffix, isPageContextRequest } = (0, handlePageContextRequestUrl_1.handlePageContextRequestUrl)(urlOriginal);
        const { hasBaseUrl } = (0, utils_1.parseUrl)(urlWithoutPageContextRequestSuffix, globalContext._baseUrl);
        if (!hasBaseUrl) {
            (0, utils_1.objectAssign)(pageContextAddendum, { httpResponse: null, errorWhileRendering: null });
            return pageContextAddendum;
        }
        (0, utils_1.objectAssign)(pageContextAddendum, {
            _isPageContextRequest: isPageContextRequest,
            _urlProcessor: (url) => (0, handlePageContextRequestUrl_1.handlePageContextRequestUrl)(url).urlWithoutPageContextRequestSuffix
        });
    }
    return pageContextAddendum;
}
// `renderPage()` calls `renderPage_()` while ensuring an `err` is always `console.error(err)` instead of `throw err`, so that `vite-plugin-ssr` never triggers a server shut down. (Throwing an error in an Express.js middleware shuts down the whole Express.js server.)
async function renderPage(pageContextInit) {
    assertArguments(...arguments);
    (0, utils_1.assert)((0, utils_1.hasProp)(pageContextInit, 'urlOriginal', 'string'));
    const pageContextOfOriginalError = {};
    try {
        return await renderPage_(pageContextInit, pageContextOfOriginalError);
    }
    catch (errOriginal) {
        assertError(errOriginal);
        if (!(0, RenderErrorPage_1.isRenderErrorPageException)(errOriginal)) {
            logError(errOriginal);
        }
        try {
            return await renderErrorPage(pageContextInit, errOriginal, pageContextOfOriginalError);
        }
        catch (err) {
            logErrorIfDifferentFromOriginal(err, errOriginal);
            const pageContext = {};
            (0, utils_1.objectAssign)(pageContext, pageContextInit);
            (0, utils_1.objectAssign)(pageContext, {
                httpResponse: null,
                errorWhileRendering: errOriginal
            });
            return pageContext;
        }
    }
}
exports.renderPage = renderPage;
async function renderErrorPage(pageContextInit, errOriginal, pageContextOfOriginalError) {
    const pageContext = {};
    {
        const pageContextInitAddendum = await initializePageContext(pageContextInit);
        (0, utils_1.objectAssign)(pageContext, pageContextInitAddendum);
        // `pageContext.httpResponse===null` should have already been handled in `renderPage()`
        (0, utils_1.assert)(!('httpResponse' in pageContext));
    }
    (0, addComputedUrlProps_1.addComputedUrlProps)(pageContext);
    (0, utils_1.objectAssign)(pageContext, {
        is404: false,
        _pageId: null,
        errorWhileRendering: errOriginal,
        routeParams: {}
    });
    if ((0, RenderErrorPage_1.isRenderErrorPageException)(pageContext.errorWhileRendering)) {
        (0, utils_1.objectAssign)(pageContext, { is404: true });
        (0, utils_1.objectAssign)(pageContext, pageContext.errorWhileRendering.pageContext);
    }
    (0, utils_1.objectAssign)(pageContext, {
        _routeMatches: pageContextOfOriginalError._routeMatches || 'ROUTE_ERROR'
    });
    return renderPageContext(pageContext);
}
function assertError(err) {
    (0, RenderErrorPage_1.assertRenderErrorPageExceptionUsage)(err);
    if (!(0, utils_1.isObject)(err)) {
        console.warn('[vite-plugin-ssr] The thrown value is:');
        console.warn(err);
        (0, utils_1.assertWarning)(false, "Your source code threw a value that is not an object. Make sure to wrap the value with `new Error()`. For example, if your code throws `throw 'some-string'` then do `throw new Error('some-string')` instead. The thrown value is printed above. Feel free to contact vite-plugin-ssr maintainers to get help.", { onlyOnce: false });
    }
}
function createHttpResponseObject(htmlRender, renderFilePath, pageContext) {
    if (htmlRender === null) {
        return null;
    }
    let statusCode;
    {
        const isError = !pageContext._pageId || (0, route_1.isErrorPageId)(pageContext._pageId);
        if (pageContext.errorWhileRendering) {
            (0, utils_1.assert)(isError);
        }
        if (!isError) {
            (0, utils_1.assert)(pageContext.is404 === null);
            statusCode = 200;
        }
        else {
            (0, utils_1.assert)(pageContext.is404 === true || pageContext.is404 === false);
            statusCode = pageContext.is404 ? 404 : 500;
        }
    }
    // The `.pageContext.json` HTTP request's body is generated by `@brillout/json-serializer` thus always a string
    (0, utils_1.assert)(!pageContext._isPageContextRequest || typeof htmlRender === 'string');
    const streamDocs = 'See https://vite-plugin-ssr.com/stream for more information.';
    return {
        statusCode,
        contentType: pageContext._isPageContextRequest ? 'application/json' : 'text/html;charset=utf-8',
        get body() {
            if (typeof htmlRender !== 'string') {
                (0, utils_1.assert)(renderFilePath);
                (0, utils_1.assertUsage)(false, errMsg('body', 'Use `pageContext.httpResponse.pipe()` or `pageContext.httpResponse.getBody()` instead'));
            }
            const body = htmlRender;
            return body;
        },
        async getBody() {
            const body = await (0, renderHtml_1.getHtmlString)(htmlRender);
            return body;
        },
        async getNodeStream() {
            (0, utils_1.assertWarning)(false, '`pageContext.httpResponse.getNodeStream()` is outdated, use `pageContext.httpResponse.pipe()` instead. ' +
                streamDocs, { onlyOnce: true, showStackTrace: true });
            const nodeStream = await (0, stream_1.getStreamReadableNode)(htmlRender);
            (0, utils_1.assertUsage)(nodeStream !== null, errMsg('getNodeStream()', fixMsg('readable', 'node')));
            return nodeStream;
        },
        getWebStream() {
            (0, utils_1.assertWarning)(false, '`pageContext.httpResponse.getWebStream(res)` is outdated, use `pageContext.httpResponse.getReadableWebStream(res)` instead. ' +
                streamDocs, { onlyOnce: true, showStackTrace: true });
            const webStream = (0, stream_1.getStreamReadableWeb)(htmlRender);
            (0, utils_1.assertUsage)(webStream !== null, errMsg('getWebStream()', fixMsg('readable', 'web')));
            return webStream;
        },
        getReadableWebStream() {
            const webStream = (0, stream_1.getStreamReadableWeb)(htmlRender);
            (0, utils_1.assertUsage)(webStream !== null, errMsg('getReadableWebStream()', fixMsg('readable', 'web')));
            return webStream;
        },
        pipeToWebWritable(writable) {
            (0, utils_1.assertWarning)(false, '`pageContext.httpResponse.pipeToWebWritable(res)` is outdated, use `pageContext.httpResponse.pipe(res)` instead. ' +
                streamDocs, { onlyOnce: true, showStackTrace: true });
            const success = (0, stream_1.pipeToStreamWritableWeb)(htmlRender, writable);
            (0, utils_1.assertUsage)(success, errMsg('pipeToWebWritable()'));
        },
        pipeToNodeWritable(writable) {
            (0, utils_1.assertWarning)(false, '`pageContext.httpResponse.pipeToNodeWritable(res)` is outdated, use `pageContext.httpResponse.pipe(res)` instead. ' +
                streamDocs, { onlyOnce: true, showStackTrace: true });
            const success = (0, stream_1.pipeToStreamWritableNode)(htmlRender, writable);
            (0, utils_1.assertUsage)(success, errMsg('pipeToNodeWritable()'));
        },
        pipe(writable) {
            if ((0, stream_1.isStreamWritableWeb)(writable)) {
                const success = (0, stream_1.pipeToStreamWritableWeb)(htmlRender, writable);
                (0, utils_1.assertUsage)(success, errMsg('pipe()'));
                return;
            }
            if ((0, stream_1.isStreamWritableNode)(writable)) {
                const success = (0, stream_1.pipeToStreamWritableNode)(htmlRender, writable);
                (0, utils_1.assertUsage)(success, errMsg('pipe()'));
                return;
            }
            (0, utils_1.assertUsage)(false, `The argument \`writable\` passed to \`pageContext.httpResponse.pipe(writable)\` doesn't seem to be ${(0, stream_1.getStreamName)('writable', 'web')} nor ${(0, stream_1.getStreamName)('writable', 'node')}.`);
        }
    };
    function errMsg(method, fixMsg) {
        let htmlRenderName;
        if (typeof htmlRender === 'string') {
            htmlRenderName = 'an HTML string';
        }
        else if ((0, stream_1.isStream)(htmlRender)) {
            htmlRenderName = (0, stream_1.inferStreamName)(htmlRender);
        }
        else {
            (0, utils_1.assert)(false);
        }
        (0, utils_1.assert)(['a ', 'an ', 'the '].some((s) => htmlRenderName.startsWith(s)));
        (0, utils_1.assert)(!fixMsg || !fixMsg.endsWith('.'));
        return [
            `\`pageContext.httpResponse.${method}\` can't be used because your \`render()\` hook (${renderFilePath}) provides ${htmlRenderName}`,
            fixMsg,
            streamDocs
        ]
            .filter(Boolean)
            .join('. ');
    }
    function fixMsg(type, standard) {
        const streamName = (0, stream_1.getStreamName)(type, standard);
        (0, utils_1.assert)(['a ', 'an ', 'the '].some((s) => streamName.startsWith(s)));
        return `Make sure your \`render()\` hook provides ${streamName} instead`;
    }
}
async function prerenderPage(pageContext) {
    (0, utils_1.assert)(pageContext._isPreRendering === true);
    (0, utils_1.objectAssign)(pageContext, {
        _isPageContextRequest: false,
        _urlProcessor: null
    });
    (0, addComputedUrlProps_1.addComputedUrlProps)(pageContext);
    await executeOnBeforeRenderHooks(pageContext);
    const renderHookResult = await executeRenderHook(pageContext);
    (0, utils_1.assertUsage)(renderHookResult.htmlRender !== null, `Cannot pre-render \`${pageContext.urlOriginal}\` because the \`render()\` hook exported by ${renderHookResult.renderFilePath} didn't return an HTML string.`);
    (0, utils_1.assert)(pageContext._isPageContextRequest === false);
    const documentHtml = await (0, renderHtml_1.getHtmlString)(renderHookResult.htmlRender);
    (0, utils_1.assert)(typeof documentHtml === 'string');
    if (!pageContext._usesClientRouter) {
        return { documentHtml, pageContextSerialized: null, pageContext };
    }
    else {
        const pageContextSerialized = (0, serializePageContextClientSide_1.serializePageContextClientSide)(pageContext);
        return { documentHtml, pageContextSerialized, pageContext };
    }
}
exports.prerenderPage = prerenderPage;
async function renderStatic404Page(globalContext) {
    const errorPageId = (0, route_1.getErrorPageId)(globalContext._allPageIds);
    if (!errorPageId) {
        return null;
    }
    const pageContext = {
        ...globalContext,
        _pageId: errorPageId,
        is404: true,
        routeParams: {},
        urlOriginal: '/fake-404-url',
        // `renderStatic404Page()` is about generating `dist/client/404.html` for static hosts; there is no Client Routing.
        _usesClientRouter: false,
        _routeMatches: []
    };
    const pageFiles = await loadPageFilesServer(pageContext);
    (0, utils_1.objectAssign)(pageContext, pageFiles);
    return prerenderPage(pageContext);
}
exports.renderStatic404Page = renderStatic404Page;
function preparePageContextForRelease(pageContext) {
    (0, addComputedUrlProps_1.assertURLs)(pageContext);
    (0, utils_1.assert)((0, utils_1.isPlainObject)(pageContext.routeParams));
    (0, utils_1.assert)('Page' in pageContext);
    (0, utils_1.assert)((0, utils_1.isObject)(pageContext.pageExports));
    (0, utils_1.assert)((0, utils_1.isObject)(pageContext.exports));
    (0, utils_1.assert)((0, utils_1.isObject)(pageContext.exportsAll));
    (0, sortPageContext_1.sortPageContext)(pageContext);
    if ((0, route_1.isErrorPageId)(pageContext._pageId)) {
        (0, utils_1.assert)((0, utils_1.hasProp)(pageContext, 'is404', 'boolean'));
        (0, serializePageContextClientSide_1.addIs404ToPageProps)(pageContext);
    }
}
async function loadPageFilesServer(pageContext) {
    const [{ exports, exportsAll, pageExports, pageFilesLoaded }] = await Promise.all([
        (0, loadPageFilesServerSide_1.loadPageFilesServerSide)(pageContext._pageFilesAll, pageContext._pageId),
        (0, analyzePageClientSide_1.analyzePageClientSideInit)(pageContext._pageFilesAll, pageContext._pageId, { sharedPageFilesAlreadyLoaded: true })
    ]);
    const { isHtmlOnly, isClientRouting, clientEntries, clientDependencies, pageFilesClientSide, pageFilesServerSide } = (0, analyzePageClientSide_1.analyzePageClientSide)(pageContext._pageFilesAll, pageContext._pageId);
    const pageContextAddendum = {};
    (0, utils_1.objectAssign)(pageContextAddendum, {
        exports,
        exportsAll,
        pageExports,
        Page: exports.Page,
        _isHtmlOnly: isHtmlOnly,
        _passToClient: (0, getPageFiles_1.getExportUnion)(exportsAll, 'passToClient'),
        _pageFilePathsLoaded: pageFilesLoaded.map((p) => p.filePath)
    });
    (0, utils_1.objectAssign)(pageContextAddendum, {
        _getPageAssets: async () => {
            if ('_pageAssets' in pageContext) {
                return pageContext._pageAssets;
            }
            else {
                const isPreRendering = pageContext._isPreRendering;
                (0, utils_1.assert)([true, false].includes(isPreRendering));
                const pageAssets = await (0, getPageAssets_1.getPageAssets)(pageContext, clientDependencies, clientEntries, isPreRendering);
                (0, utils_1.objectAssign)(pageContext, { _pageAssets: pageAssets });
                return pageContext._pageAssets;
            }
        }
    });
    {
        debugPageFiles({
            pageContext,
            isHtmlOnly,
            isClientRouting,
            pageFilesLoaded,
            pageFilesClientSide,
            pageFilesServerSide,
            clientEntries,
            clientDependencies
        });
    }
    return pageContextAddendum;
}
exports.loadPageFilesServer = loadPageFilesServer;
function debugPageFiles({ pageContext, isHtmlOnly, isClientRouting, pageFilesLoaded, pageFilesServerSide, pageFilesClientSide, clientEntries, clientDependencies }) {
    const debug = (0, utils_1.createDebugger)('vps:pageFiles', { serialization: { emptyArray: 'None' } });
    const padding = '   - ';
    debug('All page files:', printPageFiles(pageContext._pageFilesAll, true));
    debug(`URL:`, pageContext.urlOriginal);
    debug.options({ serialization: { emptyArray: 'No match' } })(`Routing:`, printRouteMatches(pageContext._routeMatches));
    debug(`pageId:`, pageContext._pageId);
    debug('Page type:', isHtmlOnly ? 'HTML-only' : 'SSR/SPA');
    debug(`Routing type:`, !isHtmlOnly && isClientRouting ? 'Client Routing' : 'Server Routing');
    debug('Server-side page files:', printPageFiles(pageFilesLoaded));
    (0, utils_1.assert)(samePageFiles(pageFilesLoaded, pageFilesServerSide));
    debug('Client-side page files:', printPageFiles(pageFilesClientSide));
    debug('Client-side entries:', clientEntries);
    debug('Client-side dependencies:', clientDependencies);
    return;
    function printRouteMatches(routeMatches) {
        if (routeMatches === 'ROUTE_ERROR') {
            return 'Routing Failed';
        }
        if (routeMatches === 'CUSTOM_ROUTE') {
            return 'Custom Routing';
        }
        return routeMatches;
    }
    function printPageFiles(pageFiles, genericPageFilesLast = false) {
        if (pageFiles.length === 0) {
            return 'None';
        }
        return ('\n' +
            pageFiles
                .sort((p1, p2) => p1.filePath.localeCompare(p2.filePath))
                .sort((0, utils_1.makeFirst)((p) => (p.isRendererPageFile ? !genericPageFilesLast : null)))
                .sort((0, utils_1.makeFirst)((p) => (p.isDefaultPageFile ? !genericPageFilesLast : null)))
                .map((p) => p.filePath)
                .map((s) => s.split('_default.page.').join(`${picocolors_1.default.blue('_default')}.page.`))
                .map((s) => s.split('/renderer/').join(`/${picocolors_1.default.red('renderer')}/`))
                .map((s) => padding + s)
                .join('\n'));
    }
}
function samePageFiles(pageFiles1, pageFiles2) {
    return (pageFiles1.every((p1) => pageFiles2.some((p2) => p2.filePath === p1.filePath)) &&
        pageFiles2.every((p2) => pageFiles1.some((p1) => p1.filePath === p2.filePath)));
}
async function executeOnBeforeRenderHooks(pageContext) {
    if (pageContext._pageContextAlreadyProvidedByPrerenderHook) {
        return;
    }
    const hook = (0, getHook_1.getHook)(pageContext, 'onBeforeRender');
    if (!hook) {
        return;
    }
    const onBeforeRender = hook.hook;
    preparePageContextForRelease(pageContext);
    const hookResult = await (0, utils_1.callHookWithTimeout)(() => onBeforeRender(pageContext), 'onBeforeRender', hook.filePath);
    (0, assertHookResult_1.assertHookResult)(hookResult, 'onBeforeRender', ['pageContext'], hook.filePath);
    const pageContextFromHook = hookResult?.pageContext;
    Object.assign(pageContext, pageContextFromHook);
}
async function executeRenderHook(pageContext) {
    const hook = (0, getHook_1.getHook)(pageContext, 'render');
    (0, utils_1.assertUsage)(hook, [
        'No server-side `render()` hook found.',
        'See https://vite-plugin-ssr.com/render-modes for more information.',
        [
            'Loaded server-side page files (none of them `export { render }`):',
            ...pageContext._pageFilePathsLoaded.map((f, i) => ` (${i + 1}): ${f}`)
        ].join('\n')
    ].join(' '));
    const render = hook.hook;
    const renderFilePath = hook.filePath;
    preparePageContextForRelease(pageContext);
    const result = await (0, utils_1.callHookWithTimeout)(() => render(pageContext), 'render', hook.filePath);
    if ((0, utils_1.isObject)(result) && !(0, renderHtml_1.isDocumentHtml)(result)) {
        (0, assertHookResult_1.assertHookResult)(result, 'render', ['documentHtml', 'pageContext'], renderFilePath);
    }
    (0, utils_1.objectAssign)(pageContext, { _renderHook: { hookFilePath: renderFilePath, hookName: 'render' } });
    let pageContextPromise = null;
    if ((0, utils_1.hasProp)(result, 'pageContext')) {
        const pageContextProvidedByRenderHook = result.pageContext;
        if ((0, utils_1.isPromise)(pageContextProvidedByRenderHook)) {
            pageContextPromise = pageContextProvidedByRenderHook;
        }
        else {
            (0, assertPageContextProvidedByUser_1.assertPageContextProvidedByUser)(pageContextProvidedByRenderHook, { hook: pageContext._renderHook });
            Object.assign(pageContext, pageContextProvidedByRenderHook);
        }
    }
    (0, utils_1.objectAssign)(pageContext, { _pageContextPromise: pageContextPromise });
    const errPrefix = 'The `render()` hook exported by ' + renderFilePath;
    const errSuffix = [
        'a string generated with the `escapeInject` template tag or a string returned by `dangerouslySkipEscape()`,',
        'see https://vite-plugin-ssr.com/escapeInject'
    ].join(' ');
    let documentHtml;
    if (!(0, utils_1.isObject)(result) || (0, renderHtml_1.isDocumentHtml)(result)) {
        (0, utils_1.assertUsage)(typeof result !== 'string', [
            errPrefix,
            'returned a plain JavaScript string which is forbidden;',
            'instead, it should return',
            errSuffix
        ].join(' '));
        (0, utils_1.assertUsage)(result === null || (0, renderHtml_1.isDocumentHtml)(result), [
            errPrefix,
            'should return `null`, a string `documentHtml`, or an object `{ documentHtml, pageContext }`',
            'where `pageContext` is `undefined` or an object holding additional `pageContext` values',
            'and `documentHtml` is',
            errSuffix
        ].join(' '));
        documentHtml = result;
    }
    else {
        (0, assertHookResult_1.assertObjectKeys)(result, ['documentHtml', 'pageContext'], errPrefix);
        if ('documentHtml' in result) {
            documentHtml = result.documentHtml;
            (0, utils_1.assertUsage)(typeof documentHtml !== 'string', [
                errPrefix,
                'returned `{ documentHtml }`, but `documentHtml` is a plain JavaScript string which is forbidden;',
                '`documentHtml` should be',
                errSuffix
            ].join(' '));
            (0, utils_1.assertUsage)(documentHtml === undefined || documentHtml === null || (0, renderHtml_1.isDocumentHtml)(documentHtml), [errPrefix, 'returned `{ documentHtml }`, but `documentHtml` should be', errSuffix].join(' '));
        }
    }
    (0, utils_1.assert)(documentHtml === undefined || documentHtml === null || (0, renderHtml_1.isDocumentHtml)(documentHtml));
    if (documentHtml === null || documentHtml === undefined) {
        return { htmlRender: null, renderFilePath };
    }
    const onErrorWhileStreaming = (err) => {
        assertError(err);
        logError(err);
        /*
        objectAssign(pageContext, {
          errorWhileRendering: err,
          _serverSideErrorWhileStreaming: true
        })
        */
    };
    const htmlRender = await (0, renderHtml_1.renderHtml)(documentHtml, pageContext, renderFilePath, onErrorWhileStreaming);
    (0, utils_1.assert)(typeof htmlRender === 'string' || (0, stream_1.isStream)(htmlRender));
    return { htmlRender, renderFilePath };
}
function assertArguments(...args) {
    const prefix = '[renderPage(pageContextInit)]';
    const pageContextInit = args[0];
    (0, utils_1.assertUsage)(pageContextInit, prefix + ' argument `pageContextInit` is missing');
    const len = args.length;
    (0, utils_1.assertUsage)(len === 1, `${prefix} You passed ${len} arguments but \`renderPage()\` accepts only one argument.'`);
    (0, utils_1.assertUsage)((0, utils_1.isPlainObject)(pageContextInit), `${prefix} \`pageContextInit\` should be a plain JavaScript object, but \`pageContextInit.constructor === ${pageContextInit.constructor}\``);
    if ('url' in pageContextInit) {
        (0, utils_1.assertWarning)(false, '`pageContext.url` has been renamed to `pageContext.urlOriginal`: replace `renderPage({ url })` with `renderPage({ urlOriginal })`. (See https://vite-plugin-ssr.com/migration/0.4.23 for more information.)', { onlyOnce: true });
        pageContextInit.urlOriginal = pageContextInit.url;
        delete pageContextInit.url;
    }
    (0, utils_1.assert)(!('url' in pageContextInit));
    (0, utils_1.assertUsage)((0, utils_1.hasProp)(pageContextInit, 'urlOriginal'), prefix + ' `pageContextInit` is missing the property `pageContextInit.urlOriginal`');
    (0, utils_1.assertUsage)(typeof pageContextInit.urlOriginal === 'string', prefix +
        ' `pageContextInit.urlOriginal` should be a string but `typeof pageContextInit.urlOriginal === "' +
        typeof pageContextInit.urlOriginal +
        '"`.');
    (0, utils_1.assertUsage)(pageContextInit.urlOriginal.startsWith('/') || pageContextInit.urlOriginal.startsWith('http'), prefix +
        ' `pageContextInit.urlOriginal` should start with `/` (e.g. `/product/42`) or `http` (e.g. `http://example.org/product/42`) but `pageContextInit.urlOriginal === "' +
        pageContextInit.urlOriginal +
        '"`');
    try {
        const { urlOriginal } = pageContextInit;
        const urlWithOrigin = urlOriginal.startsWith('http') ? urlOriginal : 'http://fake-origin.example.org' + urlOriginal;
        // We use `new URL()` to validate the URL. (`new URL(url)` throws an error if `url` isn't a valid URL.)
        new URL(urlWithOrigin);
    }
    catch (err) {
        (0, utils_1.assertUsage)(false, prefix +
            ' `pageContextInit.urlOriginal` should be a URL but `pageContextInit.urlOriginal==="' +
            pageContextInit.urlOriginal +
            '"`.');
    }
}
function warnMissingErrorPage(pageContext) {
    if (!pageContext._isProduction) {
        (0, utils_1.assertWarning)(false, 'No `_error.page.js` found. We recommend creating a `_error.page.js` file. (This warning is not shown in production.)', { onlyOnce: true });
    }
}
function logError(err) {
    assertError(err);
    if ((0, viteLogging_1.viteAlreadyLoggedError)(err)) {
        return;
    }
    // Avoid logging error twice (not sure if this actually ever happens?)
    if (hasAlreadyLogged(err)) {
        return;
    }
    (0, viteLogging_1.viteErrorCleanup)(err);
    // We ensure we print a string; Cloudflare Workers doesn't seem to properly stringify `Error` objects.
    const errStr = ((0, utils_1.hasProp)(err, 'stack') && String(err.stack)) || String(err);
    console.error(errStr);
    setAlreadyLogged(err);
}
function logErrorIfDifferentFromOriginal(err, errOriginal) {
    assertError(err);
    if (!(0, utils_1.isSameErrorMessage)(errOriginal, err) || !hasAlreadyLogged(errOriginal)) {
        logError(err);
    }
}
function hasAlreadyLogged(err) {
    if (!(0, utils_1.isObject)(err))
        return false;
    const key = '_wasAlreadyConsoleLogged';
    return err[key] === true;
}
function setAlreadyLogged(err) {
    if (!(0, utils_1.isObject)(err))
        return;
    const key = '_wasAlreadyConsoleLogged';
    err[key] = true;
}
