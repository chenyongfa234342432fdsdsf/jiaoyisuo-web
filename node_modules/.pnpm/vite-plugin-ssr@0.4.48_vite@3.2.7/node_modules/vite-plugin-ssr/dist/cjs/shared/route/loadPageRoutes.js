"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findPageRouteFile = exports.loadPageRoutes = void 0;
const error_page_1 = require("./error-page");
const utils_1 = require("./utils");
const deduceRouteStringFromFilesystemPath_1 = require("./deduceRouteStringFromFilesystemPath");
async function loadPageRoutes(pageContext) {
    await Promise.all(pageContext._pageFilesAll.filter((p) => p.fileType === '.page.route').map((p) => p.loadFile?.()));
    const { onBeforeRouteHook, filesystemRoots } = getGlobalHooks(pageContext);
    const pageRoutes = getPageRoutes(filesystemRoots, pageContext);
    return { pageRoutes, onBeforeRouteHook };
}
exports.loadPageRoutes = loadPageRoutes;
function getPageRoutes(filesystemRoots, pageContext) {
    const pageRoutes = [];
    pageContext._allPageIds
        .filter((pageId) => !(0, error_page_1.isErrorPageId)(pageId))
        .forEach((pageId) => {
        const pageRouteFile = findPageRouteFile(pageId, pageContext._pageFilesAll);
        if (!pageRouteFile) {
            const routeString = (0, deduceRouteStringFromFilesystemPath_1.deduceRouteStringFromFilesystemPath)(pageId, filesystemRoots);
            (0, utils_1.assert)(routeString.startsWith('/'));
            (0, utils_1.assert)(!routeString.endsWith('/') || routeString === '/');
            pageRoutes.push({
                pageId,
                routeString,
                pageRouteFilePath: null,
                routeType: 'FILESYSTEM'
            });
        }
        else {
            const { filePath, fileExports } = pageRouteFile;
            (0, utils_1.assert)(fileExports);
            (0, utils_1.assertUsage)('default' in fileExports, `${filePath} should have a default export.`);
            if ((0, utils_1.hasProp)(fileExports, 'default', 'string')) {
                const routeString = fileExports.default;
                (0, utils_1.assertUsage)(routeString.startsWith('/'), `A Route String should start with a leading \`/\` but \`${filePath}\` has \`export default '${routeString}'\`. Make sure to \`export default '/${routeString}'\` instead.`);
                pageRoutes.push({
                    pageId,
                    routeString,
                    pageRouteFilePath: filePath,
                    routeType: 'STRING'
                });
                return;
            }
            if ((0, utils_1.hasProp)(fileExports, 'default', 'function')) {
                const routeFunction = fileExports.default;
                let allowAsync = false;
                const allowKey = 'iKnowThePerformanceRisksOfAsyncRouteFunctions';
                if (allowKey in fileExports) {
                    (0, utils_1.assertUsage)((0, utils_1.hasProp)(fileExports, allowKey, 'boolean'), `The export \`${allowKey}\` of ${filePath} should be a boolean.`);
                    allowAsync = fileExports[allowKey];
                }
                pageRoutes.push({
                    pageId,
                    routeFunction,
                    pageRouteFilePath: filePath,
                    allowAsync,
                    routeType: 'FUNCTION'
                });
                return;
            }
            (0, utils_1.assertUsage)(false, `The default export of ${filePath} should be a string or a function.`);
        }
    });
    return pageRoutes;
}
function getGlobalHooks(pageContext) {
    let onBeforeRouteHook = null;
    const filesystemRoots = [];
    pageContext._pageFilesAll
        .filter((p) => p.fileType === '.page.route' && p.isDefaultPageFile)
        .forEach(({ filePath, fileExports }) => {
        (0, utils_1.assert)(fileExports);
        if ('onBeforeRoute' in fileExports) {
            (0, utils_1.assertUsage)((0, utils_1.hasProp)(fileExports, 'onBeforeRoute', 'function'), `\`export { onBeforeRoute }\` of ${filePath} should be a function.`);
            const { onBeforeRoute } = fileExports;
            onBeforeRouteHook = { filePath, onBeforeRoute };
        }
        if ('filesystemRoutingRoot' in fileExports) {
            (0, utils_1.assertUsage)((0, utils_1.hasProp)(fileExports, 'filesystemRoutingRoot', 'string'), `\`export { filesystemRoutingRoot }\` of ${filePath} should be a string.`);
            (0, utils_1.assertUsage)((0, utils_1.hasProp)(fileExports, 'filesystemRoutingRoot', 'string'), `\`export { filesystemRoutingRoot }\` of ${filePath} is \`'${fileExports.filesystemRoutingRoot}'\` but it should start with a leading slash \`/\`.`);
            filesystemRoots.push({
                filesystemRoot: dirname(filePath),
                routeRoot: fileExports.filesystemRoutingRoot
            });
        }
    });
    return { onBeforeRouteHook, filesystemRoots };
}
function findPageRouteFile(pageId, pageFilesAll) {
    return pageFilesAll.find((p) => p.pageId === pageId && p.fileType === '.page.route');
}
exports.findPageRouteFile = findPageRouteFile;
function dirname(filePath) {
    (0, utils_1.assert)(filePath.startsWith('/'));
    (0, utils_1.assert)(!filePath.endsWith('/'));
    const paths = filePath.split('/');
    const dirPath = (0, utils_1.slice)(paths, 0, -1).join('/') || '/';
    (0, utils_1.assert)(dirPath.startsWith('/'));
    (0, utils_1.assert)(!dirPath.endsWith('/') || dirPath === '/');
    return dirPath;
}
