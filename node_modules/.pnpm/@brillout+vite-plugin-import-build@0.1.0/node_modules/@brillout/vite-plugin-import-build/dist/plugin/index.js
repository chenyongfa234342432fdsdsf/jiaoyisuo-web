"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.importBuild = void 0;
const utils_1 = require("./utils");
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const importBuildFileName_1 = require("../shared/importBuildFileName");
const findBuildEntry_1 = require("./findBuildEntry");
const autoImporterFilePath = require.resolve('../autoImporter');
const configVersion = 1;
function importBuild(options) {
    let config;
    return {
        name: `@brillout/vite-plugin-import-build:${options.libraryName}`,
        apply: (config, env) => env.command === 'build' && (0, utils_1.viteIsSSR)(config),
        configResolved(config_) {
            config = resolveConfig(config_);
        },
        buildStart() {
            resetAutoImporter();
        },
        generateBundle(rollupOptions, rollupBundle) {
            const emitFile = this.emitFile.bind(this);
            generateImporter(emitFile, rollupOptions, rollupBundle);
        }
    };
    function resolveConfig(config) {
        var _a;
        (0, utils_1.assert)((0, utils_1.viteIsSSR)(config));
        config.vitePluginDistImporter = (_a = config.vitePluginDistImporter) !== null && _a !== void 0 ? _a : {
            libraries: [],
            importerAlreadyGenerated: false,
            disableAutoImporter: null,
            configVersion
        };
        if (config.vitePluginDistImporter.configVersion !== configVersion) {
            const otherLibrary = config.vitePluginDistImporter.libraries[0];
            (0, utils_1.assert)(otherLibrary);
            (0, utils_1.assert)(otherLibrary.libraryName !== options.libraryName);
            throw new Error(`Conflict between ${options.libraryName} and ${otherLibrary.libraryName}. Updating both to their latest version will likely solve the problem.`);
        }
        config.vitePluginDistImporter.libraries.push({
            getImporterCode: options.getImporterCode,
            libraryName: options.libraryName
        });
        if (options.disableAutoImporter !== undefined) {
            config.vitePluginDistImporter.disableAutoImporter =
                config.vitePluginDistImporter.disableAutoImporter || options.disableAutoImporter;
            (0, utils_1.assert)([true, false].includes(config.vitePluginDistImporter.disableAutoImporter));
        }
        (0, utils_1.assert)((0, utils_1.hasDefinedProp)(config, 'vitePluginDistImporter'));
        return config;
    }
    function generateImporter(emitFile, rollupOptions, rollupBundle) {
        if (config.vitePluginDistImporter.importerAlreadyGenerated)
            return;
        config.vitePluginDistImporter.importerAlreadyGenerated = true;
        const source = config.vitePluginDistImporter.libraries
            .map(({ getImporterCode }) => getImporterCode({
            findBuildEntry: (entryName) => (0, findBuildEntry_1.findBuildEntry)(entryName, rollupOptions, rollupBundle, config)
        }))
            .join('\n');
        emitFile({
            fileName: importBuildFileName_1.importBuildFileName,
            type: 'asset',
            source
        });
        setAutoImporter();
    }
    function setAutoImporter() {
        if (autoImporterIsDisabled())
            return;
        const distImporterFile = path_1.default.posix.join(getDistPathRelative(config), 'server', importBuildFileName_1.importBuildFileName);
        const { root } = config;
        (0, utils_1.assertPosixPath)(root);
        (0, fs_1.writeFileSync)(autoImporterFilePath, ["exports.status = 'SET';", `exports.load = () => { require('${distImporterFile}') };`, ''].join('\n'));
    }
    function resetAutoImporter() {
        try {
            (0, fs_1.writeFileSync)(autoImporterFilePath, ["exports.status = 'UNSET';", ''].join('\n'));
        }
        catch (_a) { }
    }
    function autoImporterIsDisabled() {
        const { disableAutoImporter } = config.vitePluginDistImporter;
        (0, utils_1.assert)([true, false, null].includes(disableAutoImporter));
        return disableAutoImporter !== null && disableAutoImporter !== void 0 ? disableAutoImporter : (0, utils_1.isYarnPnP)();
    }
}
exports.importBuild = importBuild;
function getDistPathRelative(config) {
    (0, utils_1.assert)((0, utils_1.viteIsSSR)(config));
    const { root } = config;
    (0, utils_1.assertPosixPath)(root);
    const importerDir = getImporterDir();
    const rootRelative = path_1.default.posix.relative(importerDir, root); // To `require()` an absolute path doesn't seem to work on Vercel
    let outDir = getOutDir(config);
    if ((0, utils_1.isAbsolutePath)(outDir)) {
        outDir = path_1.default.posix.relative(root, outDir);
        (0, utils_1.assert)(!(0, utils_1.isAbsolutePath)(outDir));
    }
    const distPathRelative = path_1.default.posix.join(rootRelative, outDir);
    // console.log(`root: ${root}, importerDir: ${importerDir}, rootRelative: ${rootRelative}, outDir: ${outDir}, distPathRelative: ${distPathRelative}`)
    return distPathRelative;
}
function getOutDir(config) {
    const { build: { outDir: outDirServer } } = config;
    (0, utils_1.assert)(outDirServer.endsWith('/server'));
    (0, utils_1.assertPosixPath)(outDirServer);
    const outDir = path_1.default.posix.join(outDirServer, '..');
    return outDir;
}
function getImporterDir() {
    const currentDir = (0, utils_1.toPosixPath)(__dirname + (() => '')()); // trick to avoid `@vercel/ncc` to glob import
    return path_1.default.posix.join(currentDir, '..');
}
