import {
  require_react_dom,
  require_scheduler
} from "./chunk-ZBJW5EFD.js";
import {
  require_react
} from "./chunk-XRNU55GO.js";
import {
  __toESM
} from "./chunk-S5KM4IGW.js";

// node_modules/.pnpm/react-tracked@1.7.10_rb4ld2rhs2bcj52oyr7ss5tkgq/node_modules/react-tracked/dist/index.modern.js
var import_react2 = __toESM(require_react());

// node_modules/.pnpm/use-context-selector@1.4.1_rb4ld2rhs2bcj52oyr7ss5tkgq/node_modules/use-context-selector/dist/index.modern.js
var import_react = __toESM(require_react());
var import_scheduler = __toESM(require_scheduler());
var import_react_dom = __toESM(require_react_dom());
var d = Symbol();
var f = Symbol();
var v = "undefined" == typeof window || /ServerSideRendering/.test(window.navigator && window.navigator.userAgent) ? import_react.useEffect : import_react.useLayoutEffect;
var a = import_scheduler.unstable_runWithPriority ? (e3) => (0, import_scheduler.unstable_runWithPriority)(import_scheduler.unstable_NormalPriority, e3) : (e3) => e3();
function E(r3) {
  const t3 = (0, import_react.createContext)({ [d]: { v: { current: r3 }, n: { current: -1 }, l: /* @__PURE__ */ new Set(), u: (e3) => e3() } });
  var o3;
  return t3[f] = t3.Provider, t3.Provider = (o3 = t3.Provider, ({ value: e3, children: r4 }) => {
    const t4 = (0, import_react.useRef)(e3), c3 = (0, import_react.useRef)(0), [i3, p3] = (0, import_react.useState)(null);
    i3 && (i3(e3), p3(null));
    const f3 = (0, import_react.useRef)();
    if (!f3.current) {
      const e4 = /* @__PURE__ */ new Set(), r5 = (r6, t5) => {
        (0, import_react_dom.unstable_batchedUpdates)(() => {
          c3.current += 1;
          const n3 = { n: c3.current };
          null != t5 && t5.suspense && (n3.n *= -1, n3.p = new Promise((e5) => {
            p3(() => (r7) => {
              n3.v = r7, delete n3.p, e5(r7);
            });
          })), e4.forEach((e5) => e5(n3)), r6();
        });
      };
      f3.current = { [d]: { v: t4, n: c3, l: e4, u: r5 } };
    }
    return v(() => {
      t4.current = e3, c3.current += 1, a(() => {
        f3.current[d].l.forEach((r5) => {
          r5({ n: c3.current, v: e3 });
        });
      });
    }, [e3]), (0, import_react.createElement)(o3, { value: f3.current }, r4);
  }), delete t3.Consumer, t3;
}
function h(e3, n3) {
  const o3 = (0, import_react.useContext)(e3)[d];
  if ("object" == typeof process && true && !o3)
    throw new Error("useContextSelector requires special context");
  const { v: { current: c3 }, n: { current: u3 }, l: s3 } = o3, i3 = n3(c3), [p3, l3] = (0, import_react.useReducer)((e4, r3) => {
    if (!r3)
      return [c3, i3];
    if ("p" in r3)
      throw r3.p;
    if (r3.n === u3)
      return Object.is(e4[1], i3) ? e4 : [c3, i3];
    try {
      if ("v" in r3) {
        if (Object.is(e4[0], r3.v))
          return e4;
        const t3 = n3(r3.v);
        return Object.is(e4[1], t3) ? e4 : [r3.v, t3];
      }
    } catch (e5) {
    }
    return [...e4];
  }, [c3, i3]);
  return Object.is(p3[1], i3) || l3(), v(() => (s3.add(l3), () => {
    s3.delete(l3);
  }), [s3]), p3[1];
}
function b(e3) {
  const t3 = (0, import_react.useContext)(e3)[d];
  if ("object" == typeof process && true && !t3)
    throw new Error("useContextUpdate requires special context");
  const { u: n3 } = t3;
  return n3;
}

// node_modules/.pnpm/proxy-compare@2.3.0/node_modules/proxy-compare/dist/index.modern.js
var e2 = Symbol();
var t2 = Symbol();
var r2 = Symbol();
var n2 = (e3, t3) => new Proxy(e3, t3);
var o2 = Object.getPrototypeOf;
var s2 = /* @__PURE__ */ new WeakMap();
var c2 = (e3) => e3 && (s2.has(e3) ? s2.get(e3) : o2(e3) === Object.prototype || o2(e3) === Array.prototype);
var l2 = (e3) => "object" == typeof e3 && null !== e3;
var a2 = /* @__PURE__ */ new WeakMap();
var f2 = (e3) => e3[r2] || e3;
var i2 = (s3, l3, p3) => {
  if (!c2(s3))
    return s3;
  const y2 = f2(s3), u3 = ((e3) => Object.isFrozen(e3) || Object.values(Object.getOwnPropertyDescriptors(e3)).some((e4) => !e4.writable))(y2);
  let g2 = p3 && p3.get(y2);
  return g2 && g2[1].f === u3 || (g2 = ((n3, o3) => {
    const s4 = { f: o3 };
    let c3 = false;
    const l4 = (t3, r3) => {
      if (!c3) {
        let o4 = s4.a.get(n3);
        o4 || (o4 = /* @__PURE__ */ new Set(), s4.a.set(n3, o4)), r3 && o4.has(e2) || o4.add(t3);
      }
    }, a3 = { get: (e3, t3) => t3 === r2 ? n3 : (l4(t3), i2(e3[t3], s4.a, s4.c)), has: (e3, r3) => r3 === t2 ? (c3 = true, s4.a.delete(n3), true) : (l4(r3), r3 in e3), getOwnPropertyDescriptor: (e3, t3) => (l4(t3, true), Object.getOwnPropertyDescriptor(e3, t3)), ownKeys: (t3) => (l4(e2), Reflect.ownKeys(t3)) };
    return o3 && (a3.set = a3.deleteProperty = () => false), [a3, s4];
  })(y2, u3), g2[1].p = n2(u3 ? ((e3) => {
    let t3 = a2.get(e3);
    if (!t3) {
      if (Array.isArray(e3))
        t3 = Array.from(e3);
      else {
        const r3 = Object.getOwnPropertyDescriptors(e3);
        Object.values(r3).forEach((e4) => {
          e4.configurable = true;
        }), t3 = Object.create(o2(e3), r3);
      }
      a2.set(e3, t3);
    }
    return t3;
  })(y2) : y2, g2[0]), p3 && p3.set(y2, g2)), g2[1].a = l3, g2[1].c = p3, g2[1].p;
};
var p2 = (e3, t3) => {
  const r3 = Reflect.ownKeys(e3), n3 = Reflect.ownKeys(t3);
  return r3.length !== n3.length || r3.some((e4, t4) => e4 !== n3[t4]);
};
var y = (t3, r3, n3, o3) => {
  if (Object.is(t3, r3))
    return false;
  if (!l2(t3) || !l2(r3))
    return true;
  const s3 = n3.get(f2(t3));
  if (!s3)
    return true;
  if (o3) {
    const e3 = o3.get(t3);
    if (e3 && e3.n === r3)
      return e3.g;
    o3.set(t3, { n: r3, g: false });
  }
  let c3 = null;
  for (const l3 of s3) {
    const s4 = l3 === e2 ? p2(t3, r3) : y(t3[l3], r3[l3], n3, o3);
    if (true !== s4 && false !== s4 || (c3 = s4), c3)
      break;
  }
  return null === c3 && (c3 = true), o3 && o3.set(t3, { n: r3, g: c3 }), c3;
};
var u2 = (e3) => !!c2(e3) && t2 in e3;
var g = (e3) => c2(e3) && e3[r2] || null;
var O = (e3, t3) => {
  const r3 = [], n3 = /* @__PURE__ */ new WeakSet(), o3 = (e4, s3) => {
    if (n3.has(e4))
      return;
    l2(e4) && n3.add(e4);
    const c3 = l2(e4) && t3.get(f2(e4));
    c3 ? c3.forEach((t4) => {
      o3(e4[t4], s3 ? [...s3, t4] : [t4]);
    }) : s3 && r3.push(s3);
  };
  return o3(e3), r3;
};

// node_modules/.pnpm/react-tracked@1.7.10_rb4ld2rhs2bcj52oyr7ss5tkgq/node_modules/react-tracked/dist/index.modern.js
var useAffectedDebugValue = (state, affected) => {
  const pathList = (0, import_react2.useRef)();
  (0, import_react2.useEffect)(() => {
    pathList.current = O(state, affected);
  });
  (0, import_react2.useDebugValue)(state);
};
var createTrackedSelector = (useSelector) => {
  const useTrackedSelector = () => {
    const [, forceUpdate] = (0, import_react2.useReducer)((c3) => c3 + 1, 0);
    const affected = /* @__PURE__ */ new WeakMap();
    const lastAffected = (0, import_react2.useRef)();
    const prevState = (0, import_react2.useRef)();
    const lastState = (0, import_react2.useRef)();
    (0, import_react2.useEffect)(() => {
      lastAffected.current = affected;
      if (prevState.current !== lastState.current && y(prevState.current, lastState.current, affected, /* @__PURE__ */ new WeakMap())) {
        prevState.current = lastState.current;
        forceUpdate();
      }
    });
    const selector = (0, import_react2.useCallback)((nextState) => {
      lastState.current = nextState;
      if (prevState.current && prevState.current !== nextState && lastAffected.current && !y(prevState.current, nextState, lastAffected.current, /* @__PURE__ */ new WeakMap())) {
        return prevState.current;
      }
      prevState.current = nextState;
      return nextState;
    }, []);
    const state = useSelector(selector);
    if (typeof process === "object" && true) {
      useAffectedDebugValue(state, affected);
    }
    const proxyCache = (0, import_react2.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);
    return i2(state, affected, proxyCache);
  };
  return useTrackedSelector;
};
var createContainer = (useValue, options) => {
  var _options, _options2;
  if (typeof options === "boolean") {
    console.warn("boolean option is deprecated, please specify { concurrentMode: true }");
    options = {
      concurrentMode: options
    };
  }
  const {
    stateContextName = "StateContainer",
    updateContextName = "UpdateContainer",
    concurrentMode
  } = options || {};
  const StateContext = E((_options = options) == null ? void 0 : _options.defaultState);
  const UpdateContext = (0, import_react2.createContext)((_options2 = options) == null ? void 0 : _options2.defaultUpdate);
  StateContext.displayName = stateContextName;
  UpdateContext.displayName = updateContextName;
  const Provider = (props) => {
    const [state, update] = useValue(props);
    return (0, import_react2.createElement)(UpdateContext.Provider, {
      value: update
    }, (0, import_react2.createElement)(StateContext.Provider, {
      value: state
    }, props.children));
  };
  const useSelector = (selector) => {
    if (typeof process === "object" && true) {
      const selectorOrig = selector;
      selector = (state) => {
        if (state === void 0) {
          throw new Error("Please use <Provider>");
        }
        return selectorOrig(state);
      };
    }
    const selected = h(StateContext, selector);
    (0, import_react2.useDebugValue)(selected);
    return selected;
  };
  const useTrackedState = createTrackedSelector(useSelector);
  const useUpdate = concurrentMode ? () => {
    if (typeof process === "object" && true && (0, import_react2.useContext)(UpdateContext) === void 0) {
      throw new Error("Please use <Provider>");
    }
    const contextUpdate = b(StateContext);
    const update = (0, import_react2.useContext)(UpdateContext);
    return (0, import_react2.useCallback)((...args) => {
      let result;
      contextUpdate(() => {
        result = update(...args);
      });
      return result;
    }, [contextUpdate, update]);
  } : () => {
    if (typeof process === "object" && true && (0, import_react2.useContext)(UpdateContext) === void 0) {
      throw new Error("Please use <Provider>");
    }
    return (0, import_react2.useContext)(UpdateContext);
  };
  const useTracked = () => [useTrackedState(), useUpdate()];
  return {
    Provider,
    useTrackedState,
    useTracked,
    useUpdate,
    useSelector
  };
};
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function memo(Component, propsAreEqual) {
  const WrappedComponent = (0, import_react2.forwardRef)((props, ref) => {
    Object.values(props).forEach(u2);
    return (0, import_react2.createElement)(Component, _extends({}, props, {
      ref
    }));
  });
  return (0, import_react2.memo)(WrappedComponent, propsAreEqual);
}
export {
  createContainer,
  createTrackedSelector,
  g as getUntrackedObject,
  memo
};
//# sourceMappingURL=react-tracked.js.map
