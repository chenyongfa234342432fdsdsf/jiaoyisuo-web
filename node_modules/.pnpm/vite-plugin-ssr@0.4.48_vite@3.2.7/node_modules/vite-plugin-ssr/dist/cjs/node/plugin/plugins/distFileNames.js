"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.distFileNames = void 0;
const utils_1 = require("../utils");
const path_1 = __importDefault(require("path"));
const determinePageId_1 = require("../../../shared/determinePageId");
const deduceRouteStringFromFilesystemPath_1 = require("../../../shared/route/deduceRouteStringFromFilesystemPath");
const extractAssetsPlugin_1 = require("./extractAssetsPlugin");
function distFileNames() {
    return {
        name: 'vite-plugin-ssr:distFileNames',
        apply: 'build',
        enforce: 'post',
        async configResolved(config) {
            setChunkFileNames(config, getChunkFileName);
            setAssetFileNames(config, getAssetFileName);
        }
    };
}
exports.distFileNames = distFileNames;
const BLACK_LIST = ['assertRenderHook.css'];
function getAssetFileName(assetInfo, assetFileName, config) {
    const assetsDir = getAssetsDir(config);
    // Not sure when/why this happens
    if (assetInfo.name && BLACK_LIST.includes(assetInfo.name)) {
        assetFileName ?? (assetFileName = `${assetsDir}/chunk-[hash][extname]`);
    }
    // dist/client/assets/index.page.server.jsx_extractAssets_lang.e4e33422.css
    // => dist/client/assets/index.page.server.e4e33422.css
    if (
    // Vite 2
    assetInfo.name?.endsWith('_extractAssets_lang.css') ||
        // Vite 3
        assetInfo.name?.endsWith('?extractAssets&lang.css')) {
        const nameBase = assetInfo.name.split('.').slice(0, -2).join('.');
        assetFileName ?? (assetFileName = `${assetsDir}/${nameBase}.[hash][extname]`);
    }
    assetFileName ?? (assetFileName = `${assetsDir}/[name].[hash][extname]`);
    return assetFileName;
}
function getChunkFileName(chunkInfo, chunkFileName, config) {
    const { root } = config;
    (0, utils_1.assertPosixPath)(root);
    const assetsDir = getAssetsDir(config);
    const id = chunkInfo.facadeModuleId;
    if (id) {
        (0, utils_1.assertPosixPath)(id);
    }
    (0, utils_1.assertPosixPath)(root);
    if (!chunkInfo.isDynamicEntry ||
        !id ||
        id.includes('/node_modules/') ||
        !id.startsWith(root) ||
        (id.includes('.page.server.') && extractAssetsPlugin_1.extractAssetsRE.test(id))) {
        chunkFileName ?? (chunkFileName = `${assetsDir}/chunk-[hash].js`);
        return chunkFileName;
    }
    chunkFileName ?? (chunkFileName = `${assetsDir}/[name].[hash].js`);
    const { name } = chunkInfo;
    if (name.startsWith('index.page.') || name === 'index.page') {
        const chunkName = deduceChunkNameFromFilesystemRouting(id, root);
        if (chunkName) {
            chunkFileName = chunkFileName.replace('[name]', name.replace('index', chunkName));
            return chunkFileName;
        }
    }
    return chunkFileName;
}
function deduceChunkNameFromFilesystemRouting(id, root) {
    (0, utils_1.assert)(id?.startsWith(root), { id, root });
    const pathRelative = path_1.default.posix.relative(root, id);
    (0, utils_1.assert)(!pathRelative.startsWith('.') && !pathRelative.startsWith('/'), { id, root });
    const pageId = (0, determinePageId_1.determinePageId)('/' + pathRelative);
    const routeString = (0, deduceRouteStringFromFilesystemPath_1.deduceRouteStringFromFilesystemPath)(pageId, []);
    const dirS = routeString.split('/');
    const pageFileName = dirS[dirS.length - 1];
    return pageFileName ?? null;
}
function setChunkFileNames(config, getChunkFileName) {
    var _a;
    if (!config?.build?.rollupOptions?.output) {
        // @ts-expect-error `ResolvedConfig['build']` is `readonly`
        config.build ?? (config.build = {});
        (_a = config.build).rollupOptions ?? (_a.rollupOptions = {});
        config.build.rollupOptions.output = {
            chunkFileNames: (chunkInfo) => getChunkFileName(chunkInfo, undefined, config)
        };
    }
    else if (!Array.isArray(config.build.rollupOptions.output)) {
        const chunkFileNames_original = config.build.rollupOptions.output.chunkFileNames;
        config.build.rollupOptions.output.chunkFileNames = (chunkInfo) => getChunkFileName(chunkInfo, resolveChunkFileNames(chunkFileNames_original, chunkInfo), config);
    }
    else {
        config.build.rollupOptions.output.map((output) => {
            const chunkFileNames_original = output.chunkFileNames;
            output.chunkFileNames = (chunkInfo) => getChunkFileName(chunkInfo, resolveChunkFileNames(chunkFileNames_original, chunkInfo), config);
        });
    }
}
function setAssetFileNames(config, getAssetFileName) {
    var _a;
    if (!config?.build?.rollupOptions?.output) {
        // @ts-expect-error `ResolvedConfig['build']` is `readonly`
        config.build ?? (config.build = {});
        (_a = config.build).rollupOptions ?? (_a.rollupOptions = {});
        config.build.rollupOptions.output = {
            assetFileNames: (chunkInfo) => getAssetFileName(chunkInfo, undefined, config)
        };
    }
    else if (!Array.isArray(config.build.rollupOptions.output)) {
        const chunkFileNames_original = config.build.rollupOptions.output.assetFileNames;
        config.build.rollupOptions.output.assetFileNames = (chunkInfo) => getAssetFileName(chunkInfo, resolveAssetFileNames(chunkFileNames_original, chunkInfo), config);
    }
    else {
        config.build.rollupOptions.output.map((output) => {
            const chunkFileNames_original = output.assetFileNames;
            output.assetFileNames = (chunkInfo) => getAssetFileName(chunkInfo, resolveAssetFileNames(chunkFileNames_original, chunkInfo), config);
        });
    }
}
function resolveChunkFileNames(chunkFileNames, chunkInfo) {
    if (!chunkFileNames) {
        return undefined;
    }
    if (typeof chunkFileNames === 'string') {
        return chunkFileNames;
    }
    if ((0, utils_1.isCallable)(chunkFileNames)) {
        const chunkFileName = chunkFileNames(chunkInfo);
        (0, utils_1.assert)(typeof chunkFileName === 'string');
        return chunkFileName;
    }
    (0, utils_1.assert)(false);
}
function resolveAssetFileNames(chunkFileNames, chunkInfo) {
    if (!chunkFileNames) {
        return undefined;
    }
    if (typeof chunkFileNames === 'string') {
        return chunkFileNames;
    }
    if ((0, utils_1.isCallable)(chunkFileNames)) {
        const chunkFileName = chunkFileNames(chunkInfo);
        (0, utils_1.assert)(typeof chunkFileName === 'string');
        return chunkFileName;
    }
    (0, utils_1.assert)(false);
}
function getAssetsDir(config) {
    let { assetsDir } = config.build;
    (0, utils_1.assertUsage)(assetsDir, `${assetsDir} cannot be an empty string`);
    assetsDir = assetsDir.split(/\/|\\/).filter(Boolean).join('/');
    return assetsDir;
}
