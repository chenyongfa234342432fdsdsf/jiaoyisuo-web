"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHtmlString = exports.isDocumentHtml = exports.renderHtml = exports.dangerouslySkipEscape = exports.escapeInject = void 0;
const utils_1 = require("../utils");
const injectAssets_1 = require("./injectAssets");
const stream_1 = require("./stream");
const react_streaming_1 = require("./stream/react-streaming");
const __template = '__template';
function isDocumentHtml(something) {
    if (isTemplateWrapped(something) || isEscapedString(something) || (0, stream_1.isStream)(something)) {
        (0, utils_1.checkType)(something);
        return true;
    }
    return false;
}
exports.isDocumentHtml = isDocumentHtml;
async function renderHtml(documentHtml, pageContext, renderFilePath, onErrorWhileStreaming) {
    if (isEscapedString(documentHtml)) {
        let htmlString = getEscapedString(documentHtml);
        htmlString = await (0, injectAssets_1.injectAssets)(htmlString, pageContext);
        return htmlString;
    }
    if ((0, stream_1.isStream)(documentHtml)) {
        const stream = documentHtml;
        const streamWrapper = await renderHtmlStream(stream, {
            pageContext,
            onErrorWhileStreaming
        });
        return streamWrapper;
    }
    if (isTemplateWrapped(documentHtml)) {
        const templateContent = documentHtml[__template];
        const render = renderTemplate(templateContent, renderFilePath);
        if (render.type === 'string') {
            let htmlString = render.value;
            htmlString = await (0, injectAssets_1.injectAssets)(htmlString, pageContext);
            return htmlString;
        }
        if (render.type === 'stream') {
            const streamWrapper = await renderHtmlStream(render.stream, {
                injectString: {
                    stringBegin: render.stringBegin,
                    stringEnd: render.stringEnd
                },
                pageContext,
                onErrorWhileStreaming
            });
            return streamWrapper;
        }
        (0, utils_1.checkType)(render);
        (0, utils_1.assert)(false);
    }
    (0, utils_1.checkType)(documentHtml);
    (0, utils_1.assert)(false);
}
exports.renderHtml = renderHtml;
async function renderHtmlStream(streamOriginal, { injectString, pageContext, onErrorWhileStreaming }) {
    const opts = {
        onErrorWhileStreaming,
        enableEagerStreaming: pageContext.enableEagerStreaming
    };
    if (injectString) {
        let injectToStream = null;
        if ((0, react_streaming_1.isStreamReactStreaming)(streamOriginal) && !streamOriginal.disabled) {
            injectToStream = streamOriginal.injectToStream;
        }
        const { injectAtStreamBegin, injectAtStreamEnd } = (0, injectAssets_1.injectAssetsToStream)(pageContext, injectToStream);
        (0, utils_1.objectAssign)(opts, {
            injectStringAtBegin: async () => {
                return await injectAtStreamBegin(injectString.stringBegin);
            },
            injectStringAtEnd: async () => {
                return await injectAtStreamEnd(injectString.stringEnd);
            }
        });
    }
    const streamWrapper = await (0, stream_1.processStream)(streamOriginal, opts);
    return streamWrapper;
}
function isTemplateWrapped(something) {
    return (0, utils_1.hasProp)(something, __template);
}
function isEscapedString(something) {
    const result = (0, utils_1.hasProp)(something, __escaped);
    if (result) {
        (0, utils_1.assert)((0, utils_1.hasProp)(something, __escaped, 'string'));
        (0, utils_1.checkType)(something);
    }
    return result;
}
function getEscapedString(escapedString) {
    let htmlString;
    (0, utils_1.assert)((0, utils_1.hasProp)(escapedString, __escaped));
    htmlString = escapedString[__escaped];
    (0, utils_1.assert)(typeof htmlString === 'string');
    return htmlString;
}
function escapeInject(templateStrings, ...templateVariables) {
    (0, utils_1.assertUsage)(templateStrings.length === templateVariables.length + 1 && templateStrings.every((str) => typeof str === 'string'), 'You seem to use `escapeInject` as a function, but `escapeInject` is a string template tag, see https://vite-plugin-ssr.com/escapeInject');
    return {
        [__template]: {
            templateStrings,
            templateVariables: templateVariables
        }
    };
}
exports.escapeInject = escapeInject;
const __escaped = '__escaped';
function dangerouslySkipEscape(alreadyEscapedString) {
    return _dangerouslySkipEscape(alreadyEscapedString);
}
exports.dangerouslySkipEscape = dangerouslySkipEscape;
function _dangerouslySkipEscape(arg) {
    if ((0, utils_1.hasProp)(arg, __escaped)) {
        (0, utils_1.assert)(isEscapedString(arg));
        return arg;
    }
    (0, utils_1.assertUsage)(!(0, utils_1.isPromise)(arg), `[dangerouslySkipEscape(str)] Argument \`str\` is a promise. It should be a string instead. Make sure to \`await str\`.`);
    (0, utils_1.assertUsage)(typeof arg === 'string', `[dangerouslySkipEscape(str)] Argument \`str\` should be a string but we got \`typeof str === "${typeof arg}"\`.`);
    return { [__escaped]: arg };
}
function renderTemplate(templateContent, renderFilePath) {
    let stringBegin = '';
    let stream = null;
    let stringEnd = '';
    const addString = (str) => {
        (0, utils_1.assert)(typeof str === 'string');
        if (stream === null) {
            stringBegin += str;
        }
        else {
            stringEnd += str;
        }
    };
    const { templateStrings, templateVariables } = templateContent;
    for (let i = 0; i < templateVariables.length; i++) {
        addString(templateStrings[i]);
        const templateVar = templateVariables[i];
        // Process `dangerouslySkipEscape()`
        if (isEscapedString(templateVar)) {
            const htmlString = getEscapedString(templateVar);
            // User used `dangerouslySkipEscape()` so we assume the string to be safe
            addString(htmlString);
            continue;
        }
        // Process `escapeInject` tag composition
        if (isTemplateWrapped(templateVar)) {
            const templateContentInner = templateVar[__template];
            const render = renderTemplate(templateContentInner, renderFilePath);
            (0, utils_1.assertUsage)(!(stream !== null && render.type === 'stream'), `You are trying to eject two streams in your \`escapeInject\` template tag of your render() hook exported by ${renderFilePath}. Inject only one stream instead.`);
            if (render.type === 'string') {
                addString(render.value);
            }
            else if (render.type === 'stream') {
                addString(render.stringBegin);
                stream = render.stream;
                addString(render.stringEnd);
            }
            else {
                (0, utils_1.assert)(false);
            }
            continue;
        }
        if ((0, stream_1.isStream)(templateVar)) {
            stream = templateVar;
            continue;
        }
        const getErrMsg = (typeText, end) => {
            const nth = (i === 0 && '1st') || (i === 1 && '2nd') || (i === 2 && '3rd') || `${i}-th`;
            return [
                `Each HTML variable should be a string (or a stream), but the ${nth} HTML variable is ${typeText}, see \`render()\` hook of ${renderFilePath}.`,
                end
            ]
                .filter(Boolean)
                .join(' ');
        };
        (0, utils_1.assertUsage)(!(0, utils_1.isPromise)(templateVar), getErrMsg('a promise', 'Did you forget to `await` the promise?'));
        if (templateVar === undefined || templateVar === null) {
            (0, utils_1.assertWarning)(false, getErrMsg(`\`${templateVar}\``, ''), { onlyOnce: false });
            addString('');
            continue;
        }
        {
            const varType = typeof templateVar;
            const streamNote = ['boolean', 'number', 'bigint', 'symbol'].includes(varType)
                ? null
                : '(See https://vite-plugin-ssr.com/stream for HTML streaming.)';
            (0, utils_1.assertUsage)(varType === 'string', getErrMsg(`\`typeof htmlVar === "${varType}"\``, streamNote));
        }
        // Escape untrusted template variable
        addString(escapeHtml(templateVar));
    }
    (0, utils_1.assert)(templateStrings.length === templateVariables.length + 1);
    addString(templateStrings[templateStrings.length - 1]);
    if (stream === null) {
        (0, utils_1.assert)(stringEnd === '');
        return {
            type: 'string',
            value: stringBegin
        };
    }
    return {
        type: 'stream',
        stream,
        stringBegin,
        stringEnd
    };
}
function escapeHtml(unsafeString) {
    // Source: https://stackoverflow.com/questions/6234773/can-i-escape-html-special-chars-in-javascript/6234804#6234804
    const safe = unsafeString
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    return safe;
}
async function getHtmlString(htmlRender) {
    if (typeof htmlRender === 'string') {
        return htmlRender;
    }
    if ((0, stream_1.isStream)(htmlRender)) {
        return (0, stream_1.streamToString)(htmlRender);
    }
    (0, utils_1.checkType)(htmlRender);
    (0, utils_1.assert)(false);
}
exports.getHtmlString = getHtmlString;
