"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prerender = void 0;
require("./page-files/setup");
const path_1 = __importDefault(require("path"));
const route_1 = require("../shared/route");
const utils_1 = require("./utils");
const pLimit_1 = require("../utils/pLimit");
const renderPage_1 = require("./renderPage");
const picocolors_1 = require("picocolors");
const os_1 = require("os");
const getPageFiles_1 = require("../shared/getPageFiles");
const globalContext_1 = require("./globalContext");
const vite_1 = require("vite");
const assertConfigVps_1 = require("./plugin/plugins/config/assertConfigVps");
const setProduction_1 = require("../shared/setProduction");
const getPageFilesServerSide_1 = require("../shared/getPageFiles/analyzePageServerSide/getPageFilesServerSide");
const getPageContextRequestUrl_1 = require("../shared/getPageContextRequestUrl");
const resolveRouteString_1 = require("../shared/route/resolveRouteString");
const wrongViteConfigErrorMessage = 'Your Vite config should enable pre-rendering (e.g. `ssr({ prerender: true })`), see https://vite-plugin-ssr.com/prerender-config';
async function prerender(options = {}) {
    checkOutdatedOptions(options);
    const logLevel = !!options.onPagePrerender ? 'warn' : 'info';
    if (logLevel === 'info') {
        console.log(`${(0, picocolors_1.cyan)(`vite-plugin-ssr v${utils_1.projectInfo.projectVersion}`)} ${(0, picocolors_1.green)('pre-rendering HTML...')}`);
    }
    (0, setProduction_1.setProductionEnvVar)();
    disableReactStreaming();
    const viteConfig = await (0, vite_1.resolveConfig)(options.viteConfig || {}, 'vite-plugin-ssr pre-rendering', 'production');
    assertLoadedConfig(viteConfig, options);
    (0, assertConfigVps_1.assertConfigVpsResolved)(viteConfig);
    const { outDirClient } = (0, utils_1.getOutDirs_prerender)(viteConfig);
    const { root } = viteConfig;
    const prerenderConfig = viteConfig.vitePluginSsr?.prerender;
    (0, utils_1.assertUsage)(prerenderConfig !== false, wrongViteConfigErrorMessage);
    (0, utils_1.assert)((0, utils_1.isObject)(prerenderConfig));
    const { partial = false, noExtraDir = false, parallel = true } = prerenderConfig;
    const concurrencyLimit = (0, pLimit_1.pLimit)(parallel === false || parallel === 0 ? 1 : parallel === true || parallel === undefined ? (0, os_1.cpus)().length : parallel);
    const globalContext = await (0, globalContext_1.getGlobalContext)(true);
    (0, utils_1.objectAssign)(globalContext, {
        _isPreRendering: true,
        _urlProcessor: null,
        _noExtraDir: noExtraDir ?? false,
        _root: root,
        prerenderPageContexts: []
    });
    (0, utils_1.assert)(globalContext._isProduction);
    (0, utils_1.objectAssign)(globalContext, {
        _usesClientRouter: globalContext._manifestPlugin.usesClientRouter
    });
    {
        const { pageFilesAll, allPageIds } = await (0, getPageFiles_1.getPageFilesAll)(false, globalContext._isProduction);
        (0, utils_1.objectAssign)(globalContext, {
            _pageFilesAll: pageFilesAll,
            _allPageIds: allPageIds
        });
        globalContext._pageFilesAll.forEach(assertExportNames);
    }
    (0, utils_1.objectAssign)(globalContext, options.pageContextInit);
    const doNotPrerenderList = [];
    await collectDoNoPrerenderList(globalContext, doNotPrerenderList, concurrencyLimit);
    await callPrerenderHooks(globalContext, concurrencyLimit);
    await handlePagesWithStaticRoutes(globalContext, doNotPrerenderList, concurrencyLimit);
    await callOnBeforePrerenderHook(globalContext);
    const prerenderPageIds = {};
    const htmlFiles = [];
    await routeAndPrerender(globalContext, htmlFiles, prerenderPageIds, concurrencyLimit);
    warnContradictoryNoPrerenderList(prerenderPageIds, doNotPrerenderList);
    await prerender404Page(htmlFiles, globalContext);
    if (logLevel === 'info') {
        console.log(`${(0, picocolors_1.green)(`âœ“`)} ${htmlFiles.length} HTML documents pre-rendered.`);
    }
    await Promise.all(htmlFiles.map((htmlFile) => writeHtmlFile(htmlFile, root, outDirClient, doNotPrerenderList, concurrencyLimit, options.onPagePrerender, logLevel)));
    warnMissingPages(prerenderPageIds, doNotPrerenderList, globalContext, partial);
}
exports.prerender = prerender;
async function collectDoNoPrerenderList(globalContext, doNotPrerenderList, concurrencyLimit) {
    await Promise.all(globalContext._pageFilesAll
        .filter((p) => {
        assertExportNames(p);
        if (!p.exportNames?.includes('doNotPrerender'))
            return false;
        (0, utils_1.assertUsage)(p.fileType !== '.page.client', `${p.filePath} (which is a \`.page.client.js\` file) has \`export { doNotPrerender }\` but it is only allowed in \`.page.server.js\` or \`.page.js\` files`);
        return true;
    })
        .map((p) => concurrencyLimit(async () => {
        (0, utils_1.assert)(p.loadFile);
        await p.loadFile();
    })));
    globalContext._allPageIds.forEach((pageId) => {
        const pageFilesServerSide = (0, getPageFilesServerSide_1.getPageFilesServerSide)(globalContext._pageFilesAll, pageId);
        for (const p of pageFilesServerSide) {
            if (!p.exportNames?.includes('doNotPrerender'))
                continue;
            const { fileExports } = p;
            (0, utils_1.assert)(fileExports);
            (0, utils_1.assert)((0, utils_1.hasProp)(fileExports, 'doNotPrerender'));
            const { doNotPrerender } = fileExports;
            (0, utils_1.assertUsage)(doNotPrerender === true || doNotPrerender === false, `The \`export { doNotPrerender }\` value of ${p.filePath} should be \`true\` or \`false\``);
            if (!doNotPrerender) {
                // Do pre-render `pageId`
                return;
            }
            else {
                // Don't pre-render `pageId`
                doNotPrerenderList.push({ pageId, pageFilePath: p.filePath });
            }
        }
    });
}
function assertExportNames(pageFile) {
    const { exportNames, fileType } = pageFile;
    (0, utils_1.assert)(exportNames || fileType === '.page.route', wrongViteConfigErrorMessage);
}
async function callPrerenderHooks(globalContext, concurrencyLimit) {
    // Render URLs returned by `prerender()` hooks
    await Promise.all(globalContext._pageFilesAll
        .filter((p) => {
        assertExportNames(p);
        if (!p.exportNames?.includes('prerender'))
            return false;
        (0, utils_1.assertUsage)(p.fileType === '.page.server', `${p.filePath} (which is a \`${p.fileType}.js\` file) has \`export { prerender }\` but it is only allowed in \`.page.server.js\` files`);
        return true;
    })
        .map((p) => concurrencyLimit(async () => {
        await p.loadFile?.();
        const prerender = p.fileExports?.prerender;
        if (!prerender)
            return;
        (0, utils_1.assertUsage)((0, utils_1.isCallable)(prerender), `\`export { prerender }\` of ${p.filePath} should be a function.`);
        const prerenderHookFile = p.filePath;
        (0, utils_1.assert)(prerenderHookFile);
        const prerenderResult = await prerender();
        const result = normalizePrerenderResult(prerenderResult, prerenderHookFile);
        result.forEach(({ url, pageContext }) => {
            (0, utils_1.assert)(typeof url === 'string');
            (0, utils_1.assert)(url.startsWith('/'));
            (0, utils_1.assert)(pageContext === null || (0, utils_1.isPlainObject)(pageContext));
            let pageContextFound = globalContext.prerenderPageContexts.find((pageContext) => pageContext.urlOriginal === url);
            if (!pageContextFound) {
                const pageContext = createPageContextObject(url, globalContext);
                (0, utils_1.objectAssign)(pageContext, {
                    _prerenderHookFile: prerenderHookFile
                });
                globalContext.prerenderPageContexts.push(pageContext);
                pageContextFound = pageContext;
            }
            if (pageContext) {
                (0, utils_1.objectAssign)(pageContextFound, {
                    _pageContextAlreadyProvidedByPrerenderHook: true,
                    ...pageContext
                });
            }
        });
    })));
}
async function handlePagesWithStaticRoutes(globalContext, doNotPrerenderList, concurrencyLimit) {
    // Pre-render pages with a static route
    const { pageRoutes } = await (0, route_1.loadPageRoutes)(globalContext);
    await Promise.all(pageRoutes.map((pageRoute) => concurrencyLimit(async () => {
        const { pageId } = pageRoute;
        if (doNotPrerenderList.find((p) => p.pageId === pageId)) {
            return;
        }
        let urlOriginal;
        if (!('routeString' in pageRoute)) {
            // Abort since the page's route is a Route Function
            (0, utils_1.assert)(pageRoute.routeType === 'FUNCTION');
            return;
        }
        else {
            const url = (0, resolveRouteString_1.getUrlFromRouteString)(pageRoute.routeString);
            if (!url) {
                // Abort since no URL can be deduced from a parameterized Route String
                return;
            }
            urlOriginal = url;
        }
        (0, utils_1.assert)(urlOriginal.startsWith('/'));
        // Already included in a `prerender()` hook
        if (globalContext.prerenderPageContexts.find((pageContext) => pageContext.urlOriginal === urlOriginal)) {
            // Not sure if there is a use case for it, but why not allowing users to use a `prerender()` hook in order to provide some `pageContext` for a page with a static route
            return;
        }
        const routeParams = {};
        const pageContext = createPageContextObject(urlOriginal, globalContext);
        (0, utils_1.objectAssign)(pageContext, {
            _prerenderHookFile: null,
            routeParams,
            _pageId: pageId,
            _routeMatches: [
                {
                    pageId,
                    routeType: pageRoute.pageRouteFilePath ? 'STRING' : 'FILESYSTEM',
                    routeString: urlOriginal,
                    routeParams
                }
            ]
        });
        (0, utils_1.objectAssign)(pageContext, await (0, renderPage_1.loadPageFilesServer)(pageContext));
        globalContext.prerenderPageContexts.push(pageContext);
    })));
}
function createPageContextObject(urlOriginal, globalContext) {
    const pageContext = {
        urlOriginal,
        ...globalContext
    };
    // We cannot add the computed URL properties because they can be iterated & copied in a `onBeforePrerender()` hook, e.g. `/examples/i18n/'
    // addComputedUrlProps(pageContext)
    return pageContext;
}
async function callOnBeforePrerenderHook(globalContext) {
    const pageFilesWithOnBeforePrerenderHook = globalContext._pageFilesAll.filter((p) => {
        assertExportNames(p);
        if (!p.exportNames?.includes('onBeforePrerender'))
            return false;
        (0, utils_1.assertUsage)(p.fileType !== '.page.client', `${p.filePath} (which is a \`.page.client.js\` file) has \`export { onBeforePrerender }\` but it is only allowed in \`.page.server.js\` or \`.page.js\` files`);
        (0, utils_1.assertUsage)(p.isDefaultPageFile, `${p.filePath} has \`export { onBeforePrerender }\` but it is only allowed in \`_defaut.page.\` files`);
        return true;
    });
    if (pageFilesWithOnBeforePrerenderHook.length === 0) {
        return;
    }
    (0, utils_1.assertUsage)(pageFilesWithOnBeforePrerenderHook.length === 1, 'There can be only one `onBeforePrerender()` hook. If you need to be able to define several, open a new GitHub issue.');
    await Promise.all(pageFilesWithOnBeforePrerenderHook.map((p) => p.loadFile?.()));
    const hooks = pageFilesWithOnBeforePrerenderHook.map((p) => {
        (0, utils_1.assert)(p.fileExports);
        const { onBeforePrerender } = p.fileExports;
        (0, utils_1.assert)(onBeforePrerender);
        const hookFilePath = p.filePath;
        return { hookFilePath, onBeforePrerender };
    });
    (0, utils_1.assert)(hooks.length === 1);
    const hook = hooks[0];
    const { onBeforePrerender, hookFilePath } = hook;
    const msgPrefix = `\`export { onBeforePrerender }\` of ${hookFilePath}`;
    (0, utils_1.assertUsage)((0, utils_1.isCallable)(onBeforePrerender), `${msgPrefix} should be a function.`);
    globalContext.prerenderPageContexts.forEach((pageContext) => {
        Object.defineProperty(pageContext, 'url', {
            get() {
                (0, utils_1.assertWarning)(false, msgPrefix +
                    ' uses `pageContext.url` but it should use `pageContext.urlOriginal` instead. (See https://vite-plugin-ssr.com/migration/0.4.23 for more information.)', { onlyOnce: true });
                return pageContext.urlOriginal;
            },
            enumerable: false,
            configurable: true
        });
        (0, utils_1.assert)((0, utils_1.hasPropertyGetter)(pageContext, 'url'));
        (0, utils_1.assert)(pageContext.urlOriginal);
    });
    const result = await (0, utils_1.callHookWithTimeout)(() => onBeforePrerender(globalContext), 'onBeforePrerender', hookFilePath);
    if (result === null || result === undefined) {
        return;
    }
    const errPrefix = `The \`onBeforePrerender()\` hook exported by \`${hookFilePath}\``;
    (0, utils_1.assertUsage)((0, utils_1.isObjectWithKeys)(result, ['globalContext']) && (0, utils_1.hasProp)(result, 'globalContext'), `${errPrefix} should return \`null\`, \`undefined\`, or a plain JavaScript object \`{ globalContext: { /* ... */ } }\`.`);
    const globalContextAddedum = result.globalContext;
    (0, utils_1.assertUsage)((0, utils_1.isPlainObject)(globalContextAddedum), `${errPrefix} returned \`{ globalContext }\` but \`globalContext\` should be a plain JavaScript object.`);
    (0, utils_1.objectAssign)(globalContext, globalContextAddedum);
    globalContext.prerenderPageContexts.forEach((pageContext) => {
        if (pageContext.url && !(0, utils_1.hasPropertyGetter)(pageContext, 'url')) {
            (0, utils_1.assertWarning)(false, msgPrefix +
                ' provided `pageContext.url` but it should provide `pageContext.urlOriginal` instead. (See https://vite-plugin-ssr.com/migration/0.4.23 for more information.)', { onlyOnce: true });
            pageContext.urlOriginal = pageContext.url;
        }
        delete pageContext.url;
    });
}
async function routeAndPrerender(globalContext, htmlFiles, prerenderPageIds, concurrencyLimit) {
    // Route all URLs
    await Promise.all(globalContext.prerenderPageContexts.map((pageContext) => concurrencyLimit(async () => {
        const { urlOriginal, _prerenderHookFile: prerenderHookFile } = pageContext;
        (0, utils_1.assert)(urlOriginal);
        const routeResult = await (0, route_1.route)(pageContext);
        (0, utils_1.assert)((0, utils_1.hasProp)(routeResult.pageContextAddendum, '_pageId', 'null') ||
            (0, utils_1.hasProp)(routeResult.pageContextAddendum, '_pageId', 'string'));
        if (routeResult.pageContextAddendum._pageId === null) {
            if (prerenderHookFile === null) {
                // `prerenderHookFile` is `null` when the URL was deduced by the Filesytem Routing of `.page.js` files. The `onBeforeRoute()` can override Filesystem Routing; it is therefore expected that the deduced URL may not match any page.
                (0, utils_1.assert)(routeResult.pageContextAddendum._routingProvidedByOnBeforeRouteHook);
                // Abort since the URL doesn't correspond to any page
                return;
            }
            else {
                (0, utils_1.assert)(prerenderHookFile);
                (0, utils_1.assertUsage)(false, `Your \`prerender()\` hook defined in \`${prerenderHookFile}\ returns an URL \`${urlOriginal}\` that doesn't match any page route. Make sure the URLs your return in your \`prerender()\` hooks always match the URL of a page.`);
            }
        }
        (0, utils_1.assert)(routeResult.pageContextAddendum._pageId);
        (0, utils_1.objectAssign)(pageContext, routeResult.pageContextAddendum);
        const { _pageId: pageId } = pageContext;
        const pageFilesData = await (0, renderPage_1.loadPageFilesServer)({
            ...globalContext,
            urlOriginal,
            _pageId: pageId,
            _routeMatches: pageContext._routeMatches
        });
        (0, utils_1.objectAssign)(pageContext, pageFilesData);
        (0, utils_1.objectAssign)(pageContext, { is404: null });
        const { documentHtml, pageContextSerialized } = await (0, renderPage_1.prerenderPage)(pageContext);
        htmlFiles.push({
            urlOriginal,
            pageContext,
            htmlString: documentHtml,
            pageContextSerialized,
            doNotCreateExtraDirectory: globalContext._noExtraDir,
            pageId
        });
        prerenderPageIds[pageId] = pageContext;
    })));
}
function warnContradictoryNoPrerenderList(prerenderPageIds, doNotPrerenderList) {
    Object.entries(prerenderPageIds).forEach(([pageId, { urlOriginal, _prerenderHookFile }]) => {
        const doNotPrerenderListHit = doNotPrerenderList.find((p) => p.pageId === pageId);
        if (doNotPrerenderListHit) {
            (0, utils_1.assert)(_prerenderHookFile);
            (0, utils_1.assertUsage)(false, `Your \`prerender()\` hook defined in ${_prerenderHookFile} returns the URL \`${urlOriginal}\` which matches the page with \`${doNotPrerenderListHit?.pageFilePath}#doNotPrerender === true\`. This is contradictory: either don't set \`doNotPrerender\` or remove the URL from the list of URLs to be pre-rendered.`);
        }
    });
}
function warnMissingPages(prerenderPageIds, doNotPrerenderList, globalContext, partial) {
    globalContext._allPageIds
        .filter((pageId) => !prerenderPageIds[pageId])
        .filter((pageId) => !doNotPrerenderList.find((p) => p.pageId === pageId))
        .filter((pageId) => !(0, route_1.isErrorPageId)(pageId))
        .forEach((pageId) => {
        (0, utils_1.assertWarning)(partial, `Could not pre-render page \`${pageId}.page.*\` because it has a non-static route, and no \`prerender()\` hook returned (an) URL(s) matching the page's route. Either use a \`prerender()\` hook to pre-render the page, or use the \`--partial\` option to suppress this warning.`, { onlyOnce: true });
    });
}
async function prerender404Page(htmlFiles, globalContext) {
    if (!htmlFiles.find(({ urlOriginal }) => urlOriginal === '/404')) {
        const result = await (0, renderPage_1.renderStatic404Page)(globalContext);
        if (result) {
            const urlOriginal = '/404';
            const { documentHtml, pageContext } = result;
            htmlFiles.push({
                urlOriginal,
                pageContext,
                htmlString: documentHtml,
                pageContextSerialized: null,
                doNotCreateExtraDirectory: true,
                pageId: null
            });
        }
    }
}
async function writeHtmlFile({ urlOriginal, pageContext, htmlString, pageContextSerialized, doNotCreateExtraDirectory, pageId }, root, outDirClient, doNotPrerenderList, concurrencyLimit, onPagePrerender, logLevel) {
    (0, utils_1.assert)(urlOriginal.startsWith('/'));
    (0, utils_1.assert)(!doNotPrerenderList.find((p) => p.pageId === pageId));
    const writeJobs = [
        write(urlOriginal, pageContext, '.html', htmlString, root, outDirClient, doNotCreateExtraDirectory, concurrencyLimit, onPagePrerender, logLevel)
    ];
    if (pageContextSerialized !== null) {
        writeJobs.push(write(urlOriginal, pageContext, '.pageContext.json', pageContextSerialized, root, outDirClient, doNotCreateExtraDirectory, concurrencyLimit, onPagePrerender, logLevel));
    }
    await Promise.all(writeJobs);
}
function write(urlOriginal, pageContext, fileExtension, fileContent, root, outDirClient, doNotCreateExtraDirectory, concurrencyLimit, onPagePrerender, logLevel) {
    return concurrencyLimit(async () => {
        let fileUrl;
        if (fileExtension === '.html') {
            fileUrl = (0, utils_1.urlToFile)(urlOriginal, '.html', doNotCreateExtraDirectory);
        }
        else {
            fileUrl = (0, getPageContextRequestUrl_1.getPageContextRequestUrl)(urlOriginal);
        }
        (0, utils_1.assertPosixPath)(fileUrl);
        (0, utils_1.assert)(fileUrl.startsWith('/'));
        const filePathRelative = fileUrl.slice(1);
        (0, utils_1.assert)(!filePathRelative.startsWith('/'));
        (0, utils_1.assertPosixPath)(outDirClient);
        (0, utils_1.assertPosixPath)(filePathRelative);
        const filePath = path_1.default.posix.join(outDirClient, filePathRelative);
        if (onPagePrerender) {
            const prerenderPageContext = {};
            (0, utils_1.objectAssign)(prerenderPageContext, pageContext);
            (0, utils_1.objectAssign)(prerenderPageContext, {
                _prerenderResult: {
                    filePath,
                    fileContent
                }
            });
            await onPagePrerender(prerenderPageContext);
        }
        else {
            const { promises } = require('fs');
            const { writeFile, mkdir } = promises;
            await mkdir(path_1.default.posix.dirname(filePath), { recursive: true });
            await writeFile(filePath, fileContent);
            if (logLevel === 'info') {
                (0, utils_1.assertPosixPath)(root);
                (0, utils_1.assertPosixPath)(outDirClient);
                let outDirClientRelative = path_1.default.posix.relative(root, outDirClient);
                if (!outDirClientRelative.endsWith('/')) {
                    outDirClientRelative = outDirClientRelative + '/';
                }
                console.log(`${(0, picocolors_1.gray)(outDirClientRelative)}${(0, picocolors_1.blue)(filePathRelative)}`);
            }
        }
    });
}
function normalizePrerenderResult(prerenderResult, prerenderHookFile) {
    if (Array.isArray(prerenderResult)) {
        return prerenderResult.map(normalize);
    }
    else {
        return [normalize(prerenderResult)];
    }
    function normalize(prerenderElement) {
        if (typeof prerenderElement === 'string')
            return { url: prerenderElement, pageContext: null };
        const errMsg1 = `The \`prerender()\` hook defined in \`${prerenderHookFile}\` returned an invalid value`;
        const errMsg2 = 'Make sure your `prerender()` hook returns an object `{ url, pageContext }` or an array of such objects.';
        (0, utils_1.assertUsage)((0, utils_1.isPlainObject)(prerenderElement), `${errMsg1}. ${errMsg2}`);
        (0, utils_1.assertUsage)((0, utils_1.hasProp)(prerenderElement, 'url'), `${errMsg1}: \`url\` is missing. ${errMsg2}`);
        (0, utils_1.assertUsage)((0, utils_1.hasProp)(prerenderElement, 'url', 'string'), `${errMsg1}: \`url\` should be a string (but we got \`typeof url === "${typeof prerenderElement.url}"\`).`);
        (0, utils_1.assertUsage)(prerenderElement.url.startsWith('/'), `${errMsg1}: the \`url\` with value \`${prerenderElement.url}\` doesn't start with \`/\`. Make sure each URL starts with \`/\`.`);
        Object.keys(prerenderElement).forEach((key) => {
            (0, utils_1.assertUsage)(key === 'url' || key === 'pageContext', `${errMsg1}: unexpected object key \`${key}\` ${errMsg2}`);
        });
        if (!(0, utils_1.hasProp)(prerenderElement, 'pageContext')) {
            prerenderElement['pageContext'] = null;
        }
        (0, utils_1.assertUsage)((0, utils_1.hasProp)(prerenderElement, 'pageContext', 'object'), `The \`prerender()\` hook exported by ${prerenderHookFile} returned an invalid \`pageContext\` value: make sure \`pageContext\` is a plain JavaScript object.`);
        return prerenderElement;
    }
}
function checkOutdatedOptions(options) {
    (0, utils_1.assertUsage)(options.root === undefined, 'Option `prerender({ root })` deprecated: set `prerender({ viteConfig: { root }})` instead.');
    (0, utils_1.assertUsage)(options.configFile === undefined, 'Option `prerender({ configFile })` deprecated: set `prerender({ viteConfig: { configFile }})` instead.');
    ['noExtraDir', 'partial', 'parallel'].forEach((prop) => {
        (0, utils_1.assertUsage)(options[prop] === undefined, `[prerender()] Option \`${prop}\` is deprecated. Define \`${prop}\` in \`vite.config.js\` instead. See https://vite-plugin-ssr.com/prerender-config`);
    });
    ['base', 'outDir'].forEach((prop) => {
        (0, utils_1.assertWarning)(options[prop] === undefined, `[prerender()] Option \`${prop}\` is outdated and has no effect (vite-plugin-ssr now automatically determines \`${prop}\`)`, {
            onlyOnce: true
        });
    });
}
function disableReactStreaming() {
    let mod;
    try {
        mod = (0, utils_1.loadModuleAtRuntime)('react-streaming/server');
    }
    catch {
        return;
    }
    const { disable } = mod;
    disable();
}
function assertLoadedConfig(viteConfig, options) {
    if (viteConfig.plugins.some((p) => p.name.startsWith('vite-plugin-ssr'))) {
        return;
    }
    const { configFile } = viteConfig;
    if (configFile) {
        (0, utils_1.assertUsage)(false, `${configFile} is missing vite-plugin-ssr. Add vite-plugin-ssr to \`${configFile}\`.`);
    }
    else {
        if (!options.viteConfig) {
            (0, utils_1.assertUsage)(false, `[prerender()] No \`vite.config.js\` file found at \`${process.cwd()}\`. Use the option \`prerender({ viteConfig })\`.`);
        }
        else {
            (0, utils_1.assertUsage)(false, '[prerender()] The Vite config `prerender({ viteConfig })` is missing vite-plugin-ssr.');
        }
    }
}
